<!DOCTYPE html>
<html>
	<head>
		
		<title>
			B-Tree Visualization 
		</title>
		
		<!-- css sheet for how the page is laid out -->
		
			
		<!-- jqueury stuff.  Only used for the animation speed slider. -->
				
		<!-- Javascript for the actual visualization code -->
		<script> 
        
            Function.prototype.bind = function() {
                var _function = this;
                
                var args = Array.prototype.slice.call(arguments);
                var scope = args.shift()
                return function() {
                    for (var i = 0; i < arguments.length; i++)
                    {
                        args.push(arguments[i]);
                    }
                    return _function.apply(scope, args);
                }
            }

            function EventListener()
            {
                this.events = [];
            }


            EventListener.prototype.removeListener = function(kind, scope, func)
            {
                if (this.events[kind] == undefined)
                {
                    return;
                }
                var scopeFunctions = null;
                var i;
                for (i = 0; i < this.events[kind].length; i++)
                {
                    if (this.events[kind][i].scope == scope)
                    {
                        scopeFunctions = this.events[kind][i];
                        break;
                    }	
                }
                if (scopeFunctions == null)
                {
                    return;
                }
                for (i = 0; i < scopeFunctions.functions.length; i++)
                {
                    if (scopeFunctions.functions[i] == func)
                    {
                        scopeFunctions.functions.splice(i,1);
                        return;
                    }
                }
            }


            EventListener.prototype.addListener = function(kind, scope, func)
            {
                if (this.events[kind] === undefined)
                {
                    this.events[kind] = [];
                }
                var i;
                var scopeFunctions = null;
                for (i = 0; i < this.events[kind].length; i++)
                {
                    if (this.events[kind][i].scope == scope)
                    {
                        scopeFunctions = this.events[kind][i];
                        break;
                    }
                }
                if (scopeFunctions === null)
                {
                    this.events[kind].push({scope:scope, functions:[] });
                    scopeFunctions = this.events[kind][this.events[kind].length - 1];
                }
                for (i = 0; i < scopeFunctions.functions.length; i++)
                {
                    if (scopeFunctions.functions[i] == func)
                    {
                        return;
                    }
                }
                scopeFunctions.functions.push(func);
            }

            EventListener.prototype.fireEvent = function(kind, event)
            {
                // TODO:  Should add a deep clone here ...
                if (this.events[kind] !== undefined)
                {
                    for (var i = 0; i < this.events[kind].length; i++)
                    {
                        var objects = this.events[kind][i];
                        var functs = objects.functions;
                        var scope = objects.scope
                        for (var j = 0; j <functs.length; j++)
                        {
                            var func = functs[j];
                            func.call(scope,event);
                        }
                    }
                }

            }

            // Base "class": UndoBlock
            function UndoBlock()
            {
                
            }

            UndoBlock.prototype.addUndoAnimation = function(animationList)
            {
                return false;
            }

            UndoBlock.prototype.undoInitialStep = function(world) 
            {
                
            }

            ////////////////////////////////////////////////////////////
            // UndoMove
            ////////////////////////////////////////////////////////////

            function UndoMove(id, fmX, fmy, tx, ty)
            {
                this.objectID = id;
                this.fromX = fmX;
                this.fromY = fmy;
                this.toX = tx;
                this.toY = ty;
            }


            UndoMove.prototype = new UndoBlock();
            UndoMove.prototype.constructor = UndoMove;

            UndoMove.prototype.addUndoAnimation = function (animationList)
            {
                var nextAnim = new SingleAnimation(this.objectID, this.fromX, this.fromY, this.toX, this.toY);
                animationList.push(nextAnim);
                return true;
            }

            ////////////////////////////////////////////////////////////
            // UndoCreate
            ////////////////////////////////////////////////////////////

            function UndoCreate(id)
            {
                this.objectID = id;
            }

            UndoCreate.prototype = new UndoBlock();
            UndoCreate.prototype.constructor = UndoCreate;

                
            UndoCreate.prototype.undoInitialStep = function(world)
            {
                        world.removeObject(this.objectID);
            }

            ////////////////////////////////////////////////////////////
            // UndoHighlight
            ////////////////////////////////////////////////////////////

            function UndoHighlight(id, val)
            {
                this.objectID = id;
                this.highlightValue = val;
            }

            UndoHighlight.prototype = new UndoBlock();
            UndoHighlight.prototype.constructor = UndoHighlight;

            UndoHighlight.prototype.undoInitialStep = function(world)
            {
                world.setHighlight(this.objectID, this.highlightValue);
            }


            ////////////////////////////////////////////////////////////
            // UndoSetHeight
            ////////////////////////////////////////////////////////////

            function UndoSetHeight(id, val)
            {
                this.objectID = id;
                this.height = val;
            }

            UndoSetHeight.prototype = new UndoBlock();
            UndoSetHeight.prototype.constructor = UndoSetHeight;

            UndoSetHeight.prototype.undoInitialStep = function(world)
            {
                world.setHeight(this.objectID, this.height);
            }

            ////////////////////////////////////////////////////////////
            // UndoSetWidth
            ////////////////////////////////////////////////////////////

            function UndoSetWidth(id, val)
            {
                this.objectID = id;
                this.width = val;
            }

            UndoSetWidth.prototype = new UndoBlock();
            UndoSetWidth.prototype.constructor = UndoSetWidth;

            UndoSetWidth.prototype.undoInitialStep = function(world)
            {
                world.setWidth(this.objectID, this.width);
            }


            ////////////////////////////////////////////////////////////
            // UndoSetNumElements
            ////////////////////////////////////////////////////////////
            function UndoSetNumElements(obj, newNumElems)
            {
                this.objectID = obj.objectID;
                this.sizeBeforeChange = obj.getNumElements();
                this.sizeAfterChange = newNumElems;
                if (this.sizeBeforeChange > this.sizeAfterChange)
                {
                    this.labels = new Array(this.sizeBeforeChange - this.sizeAfterChange);
                    this.colors = new Array(this.sizeBeforeChange - this.sizeAfterChange);
                    for (var i = 0; i < this.sizeBeforeChange - this.sizeAfterChange; i++)
                    {
                        this.labels[i] = obj.getText(i+this.sizeAfterChange);
                        this.colors[i] = obj.getTextColor(i+this.sizeAfterChange);
                    }
                    
                }	
            }

            UndoSetNumElements.prototype = new UndoBlock();
            UndoSetNumElements.prototype.constructor = UndoSetNumElements;


            UndoSetNumElements.prototype.undoInitialStep = function(world)
            {
                world.setNumElements(this.objectID, this.sizeBeforeChange);
                if (this.sizeBeforeChange > this.sizeAfterChange)
                {
                    for (var i = 0; i < this.sizeBeforeChange - this.sizeAfterChange; i++)
                    {
                        world.setText(this.objectID, this.labels[i], i+this.sizeAfterChange);
                        world.setTextColor(this.objectID, this.colors[i], i+this.sizeAfterChange);
                    }
                }
            }


            ////////////////////////////////////////////////////////////
            // UndoSetAlpha
            ////////////////////////////////////////////////////////////

            function UndoSetAlpha(id, alph)
            {
                this.objectID = id;
                this.alphaVal = alph;
            }

            UndoSetAlpha.prototype = new UndoBlock();
            UndoSetAlpha.prototype.constructor = UndoSetAlpha;

            UndoSetAlpha.prototype.undoInitialStep = function(world) 
            {
                world.setAlpha(this.objectID, this.alphaVal);
            }

            ////////////////////////////////////////////////////////////
            // UndoSetNull
            ////////////////////////////////////////////////////////////

            function UndoSetNull(id, nv)
            {
                this.objectID = id;
                this.nullVal = nv;
            }

            UndoSetNull.prototype = new UndoBlock();
            UndoSetNull.prototype.constructor = UndoSetNull;

            UndoSetNull.prototype.undoInitialStep = function(world) 
            {
                world.setNull(this.objectID, this.nullVal);
            }

            ////////////////////////////////////////////////////////////
            // UndoSetForegroundColor
            ////////////////////////////////////////////////////////////

            function UndoSetForegroundColor(id, color)
            {
                this.objectID = id;
                this.color = color;
            }

            UndoSetForegroundColor.prototype = new UndoBlock();
            UndoSetForegroundColor.prototype.constructor = UndoSetForegroundColor;

            UndoSetForegroundColor.prototype.undoInitialStep =  function (world)
            {
                world.setForegroundColor(this.objectID, this.color);
            }

            ////////////////////////////////////////////////////////////
            // UndoSetBackgroundColor
            ////////////////////////////////////////////////////////////

            function UndoSetBackgroundColor(id, color)
            {
                this.objectID = id;
                this.color = color;
            }

            UndoSetBackgroundColor.prototype = new UndoBlock();
            UndoSetBackgroundColor.prototype.constructor = UndoSetBackgroundColor;

            UndoSetBackgroundColor.prototype.undoInitialStep =  function (world)
            {
                world.setBackgroundColor(this.objectID, this.color);
            }



            ////////////////////////////////////////////////////////////
            // UndoSetHighlightIndex
            ////////////////////////////////////////////////////////////

            function UndoSetHighlightIndex(id, index)
            {
                this.objectID = id;
                this.index = index;
            }

            UndoSetHighlightIndex.prototype = new UndoBlock();
            UndoSetHighlightIndex.prototype.constructor = UndoSetHighlightIndex;

            UndoSetHighlightIndex.prototype.undoInitialStep =  function (world)
            {
                world.setHighlightIndex(this.objectID, this.index);
            }



            ////////////////////////////////////////////////////////////
            // UndoSetText
            ////////////////////////////////////////////////////////////



            function UndoSetText(id, str, index)
            {
                this.objectID = id;
                this.newText = str;
                this.labelIndex = index;
            }

            UndoSetText.prototype = new UndoBlock();
            UndoSetText.prototype.constructor = UndoSetText;

            UndoSetText.prototype.undoInitialStep = function(world)
            {
                world.setText(this.objectID, this.newText, this.labelIndex);
            }
            ////////////////////////////////////////////////////////////
            // UndoSetTextColor
            ////////////////////////////////////////////////////////////



            function UndoSetTextColor(id, color, index)
            {
                this.objectID = id;
                this.color = color;
                this.index = index;
            }

            UndoSetTextColor.prototype = new UndoBlock();
            UndoSetTextColor.prototype.constructor = UndoSetTextColor;

            UndoSetTextColor.prototype.undoInitialStep = function(world)
            {
                world.setTextColor(this.objectID, this.color, this.index);
            }



            ////////////////////////////////////////////////////////////
            // UndoHighlightEdge
            ////////////////////////////////////////////////////////////

            function UndoHighlightEdge(from, to, val)
            {
                this.fromID = from;
                this.toID = to;
                this.highlightValue = val;
            }

            UndoHighlightEdge.prototype = new UndoBlock();
            UndoHighlightEdge.prototype.constructor = UndoHighlightEdge;

            UndoHighlightEdge.prototype.undoInitialStep = function(world)
            {
                world.setEdgeHighlight(this.fromID, this.toID, this.highlightValue);
            }


            ////////////////////////////////////////////////////////////
            // UndoSetEdgeColor
            ////////////////////////////////////////////////////////////

            function UndoSetEdgeColor(from, to, oldColor)
            {
                this.fromID = from;
                this.toID = to;
                this.color = oldColor;
            }

            UndoSetEdgeColor.prototype = new UndoBlock();
            UndoSetEdgeColor.prototype.constructor = UndoSetEdgeColor;

            UndoSetEdgeColor.prototype.undoInitialStep = function(world)
            {
                world.setEdgeColor(this.fromID, this.toID, this.color);
            }


            ////////////////////////////////////////////////////////////
            // UndoSetEdgeAlpha
            ////////////////////////////////////////////////////////////

            function UndoSetEdgeAlpha(from, to, oldAplha)
            {
                this.fromID = from;
                this.toID = to;
                this.alpha  = oldAplha;
            }

            UndoSetEdgeAlpha.prototype = new UndoBlock();
            UndoSetEdgeAlpha.prototype.constructor = UndoSetEdgeAlpha;

            UndoSetEdgeAlpha.prototype.undoInitialStep = function(world)
            {
                world.setEdgeAlpha(this.fromID, this.toID, this.alpha);
            }

            ////////////////////////////////////////////////////////////
            // UndoSetPosition
            ////////////////////////////////////////////////////////////

            function UndoSetPosition(id, x, y)
            {
                this.objectID = id;
                this.x = x; 
                this.y = y;
            }

            UndoSetPosition.prototype = new UndoBlock();
            UndoSetPosition.prototype.constructor = UndoSetPosition;


            UndoSetPosition.prototype.undoInitialStep = function(world)
            {
                world.setNodePosition(this.objectID, this.x, this.y);
            }
            
            // Animated Object            
            function AnimatedObject()
            {
                this.init();
            }

            AnimatedObject.prototype.init  = function()
            {
                this.backgroundColor = "#FFFFFF";
                this.foregroundColor = "#000000";
                this.highlighted = false;
                this.objectID = -1;
                this.layer = 0;
                this.addedToScene = true;
                this.label = "";
                this.labelColor = "#000000";
                this.alpha = 1.0;
                this.x = 0;
                this.y = 0;
                this.minHeightDiff = 3;
                this.range = 5;
                    this.highlightIndex = -1;
                    this.highlightIndexDirty = true;
            }

            AnimatedObject.prototype.alwaysOnTop = false;

            AnimatedObject.prototype.setBackgroundColor = function(newColor)
            {
                this.backgroundColor = newColor;
            }

            AnimatedObject.prototype.setForegroundColor = function(newColor)
            {
                this.foregroundColor = newColor;
            }

            AnimatedObject.prototype.setNull = function()
            {
                
            }

            AnimatedObject.prototype.getNull = function()
            {
                return false;
            }

            AnimatedObject.prototype.setAlpha = function(newAlpha)
            {
                this.alpha = newAlpha;
            }

            AnimatedObject.prototype.getAlpha = function()
            {
                return this.alpha;
            }

            AnimatedObject.prototype.setForegroundColor = function(newColor)
            {
                this.foregroundColor = newColor;
                this.labelColor = newColor;
            }


            AnimatedObject.prototype.getHighlight = function()
            {
                return this.highlighted;
            }

            AnimatedObject.prototype.getWidth = function()
            {
                // TODO:  Do we want to throw here?  Should always override this ...
                return 0;
            }

            AnimatedObject.prototype.getHeight = function()
            {
                // TODO:  Do we want to throw here?  Should always override this ...
                return 0;
            }

            AnimatedObject.prototype.setHighlight = function(value)
            {
                this.highlighted = value;
            }

            AnimatedObject.prototype.centerX = function()
            {
                return this.x;
            }

            AnimatedObject.prototype.setWidth = function(newWidth)
            {
                // TODO:  Do we want to throw here?  Should always override this ... 
            }



            AnimatedObject.prototype.centerY = function()
            {
                return this.y;
            }


            AnimatedObject.prototype.getAlignLeftPos = function(otherObject)
            {
                return [otherObject.right()+ this.getWidth() / 2, otherObject.centerY()];
            }

            AnimatedObject.prototype.getAlignRightPos = function(otherObject)
            {
                
                return [otherObject.left() - this.getWidth() / 2, otherObject.centerY()];
            }

            AnimatedObject.prototype.getAlignTopPos = function(otherObject)
            {

                return [otherObject.centerX(), otherObject.top() - this.getHeight() / 2];
            }
            AnimatedObject.prototype.getAlignBottomPos = function(otherObject)
            {
                return [otherObject.centerX(), otherObject.bottom() + this.getHeight() / 2];
            }


            AnimatedObject.prototype.alignLeft = function(otherObject)
            {
                // Assuming centering.  Overridden method could modify if not centered
                //  (See AnimatedLabel, for instance)
                this.y = otherObject.centerY();
                this.x = otherObject.right() + this.getWidth() / 2;	
            }

            AnimatedObject.prototype.alignRight = function(otherObject)
            {
                // Assuming centering.  Overridden method could modify if not centered
                //  (See AnimatedLabel, for instance)
                this.y = otherObject.centerY();
                this.x = otherObject.left() - this.getWidth() / 2;	
            }


            AnimatedObject.prototype.alignTop = function(otherObject)
            {
                // Assuming centering.  Overridden method could modify if not centered
                
                this.x = otherObject.centerX();
                this.y = otherObject.top() - this.getHeight() / 2;	
                
                
            }


            AnimatedObject.prototype.alignBottom = function(otherObject)
            {
                this.x = otherObject.centerX();
                this.y = otherObject.bottom() + this.getHeight() / 2;		
                
            }
           
            AnimatedObject.prototype.getClosestCardinalPoint = function(fromX, fromY)
            {
                var xDelta;
                var yDelta;
                var xPos;
                var yPos;
                        
                if (fromX < this.left())
                {
                    xDelta = this.left() - fromX;
                    xPos = this.left();
                }
                else if (fromX > this.right())
                {
                    xDelta = fromX - this.right();
                    xPos = this.right();
                }
                else
                {
                    xDelta = 0;
                    xPos = this.centerX();
                }
                
                if (fromY < this.top())
                {
                    yDelta = this.top() - fromY;
                    yPos = this.top();
                }
                else if (fromY > this.bottom())
                {
                    yDelta = fromY - this.bottom();
                    yPos = this.bottom();
                }
                else
                {
                    yDelta = 0;
                    yPos = this.centerY();
                }
                        
                if (yDelta > xDelta)
                {
                    xPos = this.centerX();
                }
                else 
                {
                    yPos  = this.centerY();
                }
                
                return [xPos, yPos];
            }
                    
                    
            AnimatedObject.prototype.centered = function()
            {
                return false;
            }


            AnimatedObject.prototype.pulseHighlight = function(frameNum)
            {			
                if (this.highlighted)
                {
                            var frameMod = frameNum / 7.0;
                            var delta  = Math.abs((frameMod) % (2 * this.range  - 2) - this.range + 1)
                            this.highlightDiff =  delta + this.minHeightDiff;
                }
                        
            }
                    
            AnimatedObject.prototype.getTailPointerAttachPos = function(fromX, fromY, anchorPoint) 
            {
                return [this.x, this.y];
            }
                    
                    
            AnimatedObject.prototype.getHeadPointerAttachPos = function(fromX, fromY) 
            {
                return [this.x, this.y];
            }
                    
            AnimatedObject.prototype.identifier = function()
            {
                return this.objectID;
            }

            AnimatedObject.prototype.getText = function(index)
            {
                return this.label;
            }
                    
            AnimatedObject.prototype.getTextColor = function(textIndex)
            {			
                return this.labelColor
            }
                    
            AnimatedObject.prototype.setTextColor = function(color, textIndex)
            {
                    this.labelColor = color;
            }
                    
            AnimatedObject.prototype.setText = function(newText, textIndex)
            {
                this.label = newText;
            }

            AnimatedObject.prototype.setHighlightIndex = function(hlIndex)
            {
            this.highlightIndex = hlIndex;
            this.highlightIndexDirty = true;
            }


            AnimatedObject.prototype.getHighlightIndex = function()
            {
            return this.highlightIndex;
            }
            // Animated Label
            
			function AnimatedLabel(id, val, center, initialWidth)
			{
				this.centering = center;
				this.label = val;
				this.highlighted = false;
				this.objectID = id;
				this.alpha = 1.0;
				this.addedToScene = true;
				this.labelColor = "#000000";
				this.textWidth = 0;
				if (initialWidth != undefined)
				{
					this.textWidth = initialWidth;
				}

					this.leftWidth = -1;
					this.centerWidth = -1;
					this.highlightIndex = -1;
			}

			AnimatedLabel.prototype = new AnimatedObject();
			AnimatedLabel.prototype.constructor = AnimatedLabel;

			AnimatedLabel.prototype.alwaysOnTop = true;


			AnimatedLabel.prototype.centered = function()
			{
				return this.centering;
			}


			AnimatedLabel.prototype.draw = function(ctx)
			{
				if (!this.addedToScene)
				{
					return;
				}
				
				ctx.globalAlpha = this.alpha;
				ctx.font = '12px sans-serif';

					var startingXForHighlight = this.x; 

					if (this.highlightIndex >= this.label.length)
					{
						this.highlightIndex = -1;
					}
					if (this.highlightIndexDirty && this.highlightIndex != -1)
					{
						this.leftWidth = ctx.measureText(this.label.substring(0,this.highlightIndex)).width;
						this.centerWidth = ctx.measureText(this.label.substring(this.highlightIndex, this.highlightIndex+1)).width;
					this.highlightIndexDirty = false;
					}
				
				if (this.centering)
				{
							if (this.highlightIndex != -1)
							{
						startingXForHighlight = this.x - this.width / 2;
								ctx.textAlign = 'left';
								ctx.textBaseline   = 'middle'; 
							}
							else
							{
							ctx.textAlign = 'center';
								ctx.textBaseline   = 'middle'; 
							}
				}
				else
				{
					ctx.textAlign = 'left';
					ctx.textBaseline   = 'top'; 
				}
				if (this.highlighted)
				{
					ctx.strokeStyle = "#ffaaaa";
					ctx.fillStyle = "#ff0000";
					ctx.lineWidth = this.highlightDiff;
					ctx.strokeText(this.label, this.x, this.y);		
					//ctx.fillText(this.label, this.x, this.y);
				}
				ctx.strokeStyle = this.labelColor;
				ctx.fillStyle = this.labelColor;
				ctx.lineWidth = 1;
				strList = this.label.split("\n");
				if (strList.length == 1)
				{
							if (this.highlightIndex == -1)
							{
								ctx.fillText(this.label, this.x, this.y); 
							}
							else
							{
								var leftStr = this.label.substring(0, this.highlightIndex);
								var highlightStr = this.label.substring(this.highlightIndex, this.highlightIndex + 1)
								var rightStr = this.label.substring(this.highlightIndex + 1)
								ctx.fillText(leftStr, startingXForHighlight, this.y)
							ctx.strokeStyle = "#FF0000";
							ctx.fillStyle = "#FF0000";
								ctx.fillText(highlightStr, startingXForHighlight + this.leftWidth, this.y)


							ctx.strokeStyle = this.labelColor;
							ctx.fillStyle = this.labelColor;
								ctx.fillText(rightStr, startingXForHighlight + this.leftWidth + this.centerWidth, this.y)


							}
					//this.textWidth = ctx.measureText(this.label).width;
				}
				else
				{
					var offset = (this.centering)?  (1.0 - strList.length) / 2.0 : 0;
					for (var i = 0; i < strList.length; i++)
					{
						ctx.fillText(strList[i], this.x, this.y + offset + i * 12);
						//this.textWidth = Math.max(this.textWidth, ctx.measureText(strList[i]).width);
					}		
				}
				ctx.closePath();
			}


			AnimatedLabel.prototype.getAlignLeftPos = function(otherObject)
			{
				if (this.centering)
				{
				return [otherObject.left() - this.textWidth / 2, this.y = otherObject.centerY()];
				}
				else
				{
				return [otherObject.left() - this.textWidth, otherObject.centerY() - 5];
				}
			}

			AnimatedLabel.prototype.alignLeft = function(otherObject)
			{
				if (this.centering)
				{
					this.y = otherObject.centerY();
					this.x = otherObject.left() - this.textWidth / 2;
				}
				else
				{
					this.y = otherObject.centerY() - 5;
					this.x = otherObject.left() - this.textWidth;
				}
			}

			AnimatedLabel.prototype.alignRight = function(otherObject)
			{
				if (this.centering)
				{
					this.y = otherObject.centerY();
					this.x = otherObject.right() + this.textWidth / 2;
				}
				else
				{
					this.y = otherObject.centerY() - 5;
					this.x = otherObject.right();
				}
			}
			AnimatedLabel.prototype.getAlignRightPos = function(otherObject)
			{
				if (this.centering)
				{
				return [otherObject.right() + this.textWidth / 2, otherObject.centerY()];
				}
				else
				{
				return [otherObject.right(), otherObject.centerY() - 5];
				}
			}


			AnimatedLabel.prototype.alignTop = function(otherObject)
			{
				if (this.centering)
				{
					this.y = otherObject.top() - 5;
					this.x = otherObject.centerX();
				}
				else
				{
					this.y = otherObject.top() - 10;
					this.x = otherObject.centerX() -this.textWidth / 2;
				}
			}


			AnimatedLabel.prototype.getAlignTopPos = function(otherObject)
			{
				if (this.centering)
				{
					return [otherObject.centerX(), otherObject.top() - 5];
				}
				else
				{
					return [otherObject.centerX() -this.textWidth / 2, otherObject.top() - 10];
				}
			}


			AnimatedLabel.prototype.alignBottom = function(otherObject)
			{
				if (this.centering)
				{
					this.y = otherObject.bottom() + 5;
					this.x = otherObject.centerX();
				}
				else
				{
					this.y = otherObject.bottom();
					this.x = otherObject.centerX() - this.textWidth / 2;
				}
			}


			AnimatedLabel.prototype.getAlignBottomPos = function(otherObject)
			{
				if (this.centering)
				{
					return [otherObject.centerX(),  otherObject.bottom() + 5];
				}
				else
				{
					return [otherObject.centerX() - this.textWidth / 2,  otherObject.bottom()];
				}
			}



			AnimatedLabel.prototype.getWidth = function()
			{
				return this.textWidth;
			}

			AnimatedLabel.prototype.getHeight = function()
			{
				return 10;  // HACK!  HACK!  HACK!  HACK!
			}


			AnimatedLabel.prototype.setHighlight = function(value)
			{
				this.highlighted = value;
			}
					
			AnimatedLabel.prototype.createUndoDelete = function()
			{
				return new UndoDeleteLabel(this.objectID, this.label, this.x, this.y, this.centering, this.labelColor, this.layer, this.highlightIndex);
			}
					
					
			AnimatedLabel.prototype.centerX = function()
			{
				if (this.centering)
				{
					return this.x;
				}
				else 
				{
					return this.x + this.textWidth; 
				}
				
			}
				
			AnimatedLabel.prototype.centerY = function()
			{
				if (this.centering)
				{
					return this.y;
				}
				else 
				{
					return this.y + 5; // 
				}
			
			}
				
			AnimatedLabel.prototype.top = function()	   
			{
				if (this.centering)
				{
					return  this.y - 5; //TODO: Un-Hardwire
				}
				else 
				{
						return this.y;   
				}
			}


			AnimatedLabel.prototype.bottom = function()
			{
			if (this.centering)
			{
				return  this.y + 5; // TODO: + height / 2;
			}
			else 
			{
				return  this.y + 10; // TODO: + hieght;
			}
			}
				
				
			AnimatedLabel.prototype.right = function()
			{
			if (this.centering)
			{
				return  this.x + this.textWidth / 2; // TODO: + width / 2;
			}
			else
			{
				return  this.x + this.textWidth; // TODO: + width;
			}
			}


			AnimatedLabel.prototype.left = function()
			{
			if (this.centering)
			{
				return this. x - this.textWidth / 2;
			}
			else
			{
				return  this.x; // TODO:  - a little?
			}
			}


			AnimatedLabel.prototype.setHighlightIndex = function(hlIndex)
			{
				// Only allow highlight index for labels that don't have End-Of-Line
				if (this.label.indexOf("\n") == -1 && this.label.length > hlIndex)
				{
					this.highlightIndex = hlIndex;
					this.highlightIndexDirty = true;
				}
				else
				{
					this.highlightIndex = -1;

				}
			}


			AnimatedLabel.prototype.getTailPointerAttachPos = function(fromX, fromY, anchorPoint)
			{			 
				return this.getClosestCardinalPoint(fromX, fromY); 
			}

			AnimatedLabel.prototype.getHeadPointerAttachPos = function (fromX, fromY) 
			{
				return this.getClosestCardinalPoint(fromX, fromY);			
			}

			AnimatedLabel.prototype.setText = function(newText, textIndex, initialWidth)
			{
				this.label = newText;
				if (initialWidth != undefined)
				{
					this.textWidth = initialWidth;
				}
			}



			function UndoDeleteLabel(id, lab, x, y, centered, color, l, hli)
			{
				this.objectID = id;
				this.posX = x;
				this.posY = y;
				this.nodeLabel = lab;
				this.labCentered = centered;
				this.labelColor = color;
				this.layer = l;
					this.highlightIndex = hli;
					this.dirty = true;
			}

			UndoDeleteLabel.prototype = new UndoBlock();
			UndoDeleteLabel.prototype.constructor = UndoDeleteLabel;

			UndoDeleteLabel.prototype.undoInitialStep = function(world)
			{
				world.addLabelObject(this.objectID, this.nodeLabel, this.labCentered);
				world.setNodePosition(this.objectID, this.posX, this.posY);
				world.setForegroundColor(this.objectID, this.labelColor);
				world.setLayer(this.objectID, this.layer);
			}

            //Animated Rectangle
            
			AnimatedRectangle = function(id, val, wth, hgt,  xJust, yJust, fillColor, edgeColor)
			{
				this.w = wth;
				this.h = hgt;
				this.xJustify = xJust;
				this.yJustify = yJust;
				this.label = val;
				this.labelColor = edgeColor
				
				this.backgroundColor = fillColor;
				this.foregroundColor = edgeColor;
				this.labelColor = this.foregroundColor;
				this.highlighted = false;
				this.objectID = id;
				this.nullPointer = false;
				this.alpha = 1.0;
				this.addedToScene = true;
				
			}

			AnimatedRectangle.prototype = new AnimatedObject();
			AnimatedRectangle.prototype.constructor = AnimatedRectangle;

			AnimatedRectangle.prototype.setNull = function(np)
			{
				this.nullPointer = np;
			}

			AnimatedRectangle.prototype.getNull = function()
			{
				return this.nullPointer;
			}


			AnimatedRectangle.prototype.left = function()
			{
				if (this.xJustify == "left")
				{
					return  this.x;
				}
				else if (this.xJustify == "center")
				{
					return this.x - this.w / 2.0;   
				}
				else // (this.xJustify == "right")
				{
					return this.x - this.w;   
				}
				
			}

			AnimatedRectangle.prototype.centerX = function()
			{
				if (this.xJustify == "center")
				{
					return this.x;
				}
				else if (this.xJustify == "left")
				{
					return this.x + this.w / 2.0;
				}
				else // (this.xJustify == "right")
				{
					return this.x - this.w / 2.0;
				}
			}

			AnimatedRectangle.prototype.centerY = function()
			{
				if (this.yJustify == "center")
				{
					return this.y;
				}
				else if (this.yJustify == "top")
				{
					return this.y + this.h / 2.0;
				}
				else // (this.xJustify == "bottom")
				{
					return this.y - this.w / 2.0;
				}
				
			}

			AnimatedRectangle.prototype.top = function()
			{
				if (this.yJustify == "top")
				{
					return  this.y;
				}
				else if (this.yJustify == "center")
				{
					return this.y - this.h / 2.0;   
				}
				else //(this.xJustify == "bottom")
				{
					return this.y - this.h;   
				}
			}

			AnimatedRectangle.prototype.bottom = function()
			{
				if (this.yJustify == "top")
				{
					return  this.y + this.h;
				}
				else if (this.yJustify == "center")
				{
					return this.y + this.h / 2.0;   
				}
				else //(this.xJustify == "bottom")
				{
					return this.y;   
				}
			}


			AnimatedRectangle.prototype.right = function()
			{
				if (this.xJustify == "left")
				{
					return  this.x + this.w;
				}
				else if (this.xJustify == "center")
				{
					return this.x + this.w / 2.0;   
				}
				else // (this.xJustify == "right")
				{
					return this.x;   
				}
			}


			AnimatedRectangle.prototype.getHeadPointerAttachPos = function(fromX, fromY)
			{
				return this.getClosestCardinalPoint(fromX, fromY);			
			}


			AnimatedRectangle.prototype.setWidth = function(wdth)
			{
				this.w = wdth;
			}


			AnimatedRectangle.prototype.setHeight = function(hght)
			{
				this.h = hght;
			}

			AnimatedRectangle.prototype.getWidth = function()
			{
				return this.w;
			}

			AnimatedRectangle.prototype.getHeight = function()
			{
				return this.h;
			}


			// TODO:  Fix me!
			AnimatedRectangle.prototype.draw = function(context)
			{
				if (!this.addedToScene)
				{
					return;
				}
				
				var startX;
				var startY;
				var labelPosX;
				var labelPosY;
				
				context.globalAlpha = this.alpha;
				
				if (this.xJustify == "left")
				{
					startX = this.x;
					labelPosX = this.x + this.w / 2.0;
				}
				else if (this.xJustify == "center")
				{
					startX = this.x-this.w / 2.0;
					labelPosX = this.x;
					
				}
				else if (this.xJustify == "right")
				{
					startX = this.x-this.w;
					labelPosX = this.x - this.w / 2.0 
				}
				if (this.yJustify == "top")
				{
					startY = this.y;
					labelPosY = this.y + this.h / 2.0;
				}
				else if (this.yJustify == "center")
				{
					startY = this.y - this.h / 2.0;
					labelPosY = this.y;
					
				}
				else if (this.yJustify == "bottom")
				{
					startY = this.y - this.h;
					labelPosY = this.y - this.h / 2.0;
				}
				
				context.lineWidth = 1;
				
				if (this.highlighted)
				{
					context.strokeStyle = "#ff0000";
					context.fillStyle = "#ff0000";
					
					context.beginPath();
					context.moveTo(startX - this.highlightDiff,startY- this.highlightDiff);
					context.lineTo(startX+this.w + this.highlightDiff,startY- this.highlightDiff);
					context.lineTo(startX+this.w+ this.highlightDiff,startY+this.h + this.highlightDiff);
					context.lineTo(startX - this.highlightDiff,startY+this.h + this.highlightDiff);
					context.lineTo(startX - this.highlightDiff,startY - this.highlightDiff);				
					context.closePath();
					context.stroke();
					context.fill();
					
				}
				context.strokeStyle = this.foregroundColor;
				context.fillStyle = this.backgroundColor;
				
				context.beginPath();
				context.moveTo(startX ,startY);
				context.lineTo(startX + this.w, startY);
				context.lineTo(startX + this.w, startY + this.h);
				context.lineTo(startX, startY + this.h);
				context.lineTo(startX, startY);
				context.closePath();
				context.stroke();
				context.fill();
				
				if (this.nullPointer)
				{
					context.beginPath();
					context.moveTo(startX ,startY);
					context.lineTo(startX + this.w, startY + this.h);
					context.closePath();
					context.stroke();
				}
				
				context.fillStyle = this.labelColor;
				
				context.textAlign = 'center';
				context.font         = '12px sans-serif';
				context.textBaseline   = 'middle'; 
				context.lineWidth = 1;
				context.fillText(this.label, this.x, this.y); 
				
				
				
			}

			AnimatedRectangle.prototype.setText = function(newText, textIndex)
			{
				this.label = newText;
				// TODO:  setting text position?
			}


			AnimatedRectangle.prototype.createUndoDelete = function() 
			{
				// TODO: Add color?
				return new UndoDeleteRectangle(this.objectID, this.label, this.x, this.y, this.w, this.h, this.xJustify, this.yJustify, this.backgroundColor, this.foregroundColor, this.highlighted, this.layer);
			}

			AnimatedRectangle.prototype.setHighlight = function(value)
			{
				this.highlighted = value;
			}



			function UndoDeleteRectangle(id, lab, x, y, w, h, xJust, yJust, bgColor, fgColor, highlight, lay)
			{
				this.objectID = id;
				this.posX = x;
				this.posY = y;
				this.width = w;
				this.height = h;
				this.xJustify = xJust;
				this.yJustify = yJust;
				this.backgroundColor= bgColor;
				this.foregroundColor = fgColor;
				this.nodeLabel = lab;
				this.layer = lay;
				this.highlighted = highlight;
			}

			UndoDeleteRectangle.prototype = new UndoBlock();
			UndoDeleteRectangle.prototype.constructor = UndoDeleteRectangle;


			UndoDeleteRectangle.prototype.undoInitialStep = function(world)
			{
				world.addRectangleObject(this.objectID, this.nodeLabel, this.width, this.height, this.xJustify, this.yJustify, this.backgroundColor, this.foregroundColor);
				world.setNodePosition(this.objectID, this.posX, this.posY);
				world.setLayer(this.objectID, this.layer);
				world.setHighlight(this.objectID, this.highlighted);
			}

            //Line
            
			var LINE_maxHeightDiff = 5;
			var LINE_minHeightDiff = 3;
			var LINE_range= LINE_maxHeightDiff - LINE_minHeightDiff + 1;
			var LINE_highlightDiff = 3;

				
			function Line(n1, n2, color, cv, d, weight, anchorIndex)
			{
				this.arrowHeight = 8;
				this. arrowWidth = 4;

				this.Node1 = n1;
				this.Node2 = n2;
				this.Dirty = false;
				this.directed = d;
				this.edgeColor = color;
				this.edgeLabel = weight;
				this.highlighted = false;
				this.addedToScene = true;
				this.anchorPoint = anchorIndex;
				this.highlightDiff = 0;
				this.curve = cv;

				this.alpha = 1.0;
				this.color = function color()
				{
					return this.edgeColor;   
				}
				
				this.setColor = function(newColor)
				{
					this.edgeColor = newColor;
					Dirty = true;
				}
				
				this.setHighlight = function(highlightVal)
				{
					this.highlighted = highlightVal;   
				}
					
				this.pulseHighlight = function(frameNum)
				{
				if (this.highlighted)
				{
					var frameMod = frameNum / 14.0;
					var delta  = Math.abs((frameMod) % (2 * LINE_range  - 2) - LINE_range + 1)
					this.highlightDiff =  delta + LINE_minHeightDiff;
					Dirty = true;			   
				}
				}
				
				
				this.hasNode = function(n)
				{
					return ((this.Node1 == n) || (this.Node2 == n));   
				}
				
				
				this.createUndoDisconnect  = function()
					{
					return new UndoConnect(this.Node1.objectID, this.Node2.objectID, true, this.edgeColor, this.directed, this.curve, this.edgeLabel, this.anchorPoint);
				}
				
				
				this.sign = function(n)
				{
				if (n > 0)
				{
					return 1;
				}
				else
				{
					return -1;
				}
				}
				
				
				this.drawArrow = function(pensize, color, context)
				{		
					context.strokeStyle = color;
					context.fillStyle = color;
					context.lineWidth = pensize;
					var fromPos = this.Node1.getTailPointerAttachPos(this.Node2.x, this.Node2.y, this.anchorPoint);
					var toPos = this.Node2.getHeadPointerAttachPos(this.Node1.x, this.Node1.y);

					var fromPos = this.Node1.getTailPointerAttachPos(this.Node2.x, this.Node2.y, this.anchorPoint);
					var toPos = this.Node2.getHeadPointerAttachPos(this.Node1.x, this.Node1.y);

					var deltaX = toPos[0] - fromPos[0];
					var deltaY = toPos[1] - fromPos[1];
					var midX = (deltaX) / 2.0 + fromPos[0];
					var midY = (deltaY) / 2.0 + fromPos[1];
					var controlX = midX - deltaY * this.curve;

					var controlY = midY + deltaX * this.curve;

					context.beginPath();
					context.moveTo(fromPos[0], fromPos[1]);
					context.quadraticCurveTo(controlX, controlY, toPos[0], toPos[1]);
					context.stroke();
					//context.closePath();
						
					// Position of the edge label:  First, we will place it right along the
					// middle of the curve (or the middle of the line, for curve == 0)
					var labelPosX = 0.25* fromPos[0] + 0.5*controlX + 0.25*toPos[0]; 
					var labelPosY =  0.25* fromPos[1] + 0.5*controlY + 0.25*toPos[1]; 
						
					// Next, we push the edge position label out just a little in the direction of
					// the curve, so that the label doesn't intersect the cuve (as long as the label
					// is only a few characters, that is)
					var midLen = Math.sqrt(deltaY*deltaY + deltaX*deltaX);
					if (midLen != 0)
					{
						labelPosX +=  (- deltaY * this.sign(this.curve))  / midLen * 10 
						labelPosY += ( deltaX * this.sign(this.curve))  / midLen * 10  
					}
						


					context.textAlign = 'center';
					context.font         = '12px sans-serif';
					context.textBaseline   = 'middle'; 
					context.fillText(this.edgeLabel, labelPosX, labelPosY);

					if (this.directed)
					{
						var xVec = controlX - toPos[0];
						var yVec = controlY - toPos[1];
						var len = Math.sqrt(xVec * xVec + yVec*yVec);
					
						if (len > 0)
						{
							xVec = xVec / len
							yVec = yVec / len;
							
							context.beginPath();
							context.moveTo(toPos[0], toPos[1]);
							context.lineTo(toPos[0] + xVec*this.arrowHeight - yVec*this.arrowWidth, toPos[1] + yVec*this.arrowHeight + xVec*this.arrowWidth);
							context.lineTo(toPos[0] + xVec*this.arrowHeight + yVec*this.arrowWidth, toPos[1] + yVec*this.arrowHeight - xVec*this.arrowWidth);
							context.lineTo(toPos[0], toPos[1]);
							context.closePath();
							context.stroke();
							context.fill();
						}

					}
					
				}
				
				
				this.draw = function(ctx)
				{
					if (!this.addedToScene)
					{
						return;   
					}
					ctx.globalAlpha = this.alpha;

						if (this.highlighted)
							this.drawArrow(this.highlightDiff, "#FF0000", ctx);
						this.drawArrow(1, this.edgeColor, ctx);
				}
				
				
			}
				


			function UndoConnect(from, to, createConnection, edgeColor, isDirected, cv, lab, anch)
			{
				this.fromID = from;
				this.toID = to;
				this.connect = createConnection;
				this.color = edgeColor;
				this.directed = isDirected;
				this.curve = cv;
				this.edgeLabel = lab;
				this.anchorPoint = anch;
			}


			UndoConnect.prototype.undoInitialStep = function(world)
			{
				if (this.connect)
				{
					world.connectEdge(this.fromID, this.toID, this.color, this.curve, this.directed, this.edgeLabel,this.anchorPoint);
				}
				else
				{
					world.disconnect(this.fromID,this.toID);
				}
			}


			UndoConnect.prototype.addUndoAnimation = function(animationList)
			{
				return false;
			}

            //Animated B Tree Node
            
			function AnimatedBTreeNode(id, widthPerElem, h, numElems,  fillColor, edgeColor)
			{
				fillColor = (fillColor == undefined)? "#FFFFFF" : fillColor;
				edgeColor = (edgeColor == undefined)? "#000000" : edgeColor;
				this.init(id, widthPerElem, h, numElems,  fillColor, edgeColor);
			}

			AnimatedBTreeNode.prototype = new AnimatedObject();
			AnimatedBTreeNode.prototype.constructor = AnimatedBTreeNode;
			AnimatedBTreeNode.superclass = AnimatedObject.prototype;

			AnimatedBTreeNode.MIN_WIDTH = 10;
			AnimatedBTreeNode.EDGE_POINTER_DISPLACEMENT = 5;


			AnimatedBTreeNode.prototype.init = function(id, widthPerElem, h, numElems,  fillColor, edgeColor)
			{
				
				var  MIN_WIDTH = 10;
				AnimatedBTreeNode.superclass.init.call(this);
				this.objectID = id;
				
				
				this.backgroundColor = fillColor;
				this.foregroundColor = edgeColor;
				
				this.widthPerElement = widthPerElem;
				this.nodeHeight = h;
				this.numLabels = numElems;
				this.labels = new Array(this.numLabels);
				this.labelColors = new Array(this.numLabels);
				for (var i = 0; i < this.numLabels; i++)
				{
					this.labelColors[i] = this.foregroundColor;
				}
			}
				
			AnimatedBTreeNode.prototype.getNumElements = function()
			{
				return this.numLabels;
			}

			AnimatedBTreeNode.prototype.getWidth = function()
			{
				if (this.numLabels > 0)
				{
					return  (this.widthPerElement * this.numLabels);
				}
				else
				{
					return AnimatedBTreeNode.MIN_WIDTH;
				}
			}


			AnimatedBTreeNode.prototype.setNumElements = function(newNumElements)
			{
				var i;
				if (this.numLabels < newNumElements)
				{
					for (i = this.numLabels; i < newNumElements; i++)
					{
						this.labels[i] = "";
						this.labelColors[i] = this.foregroundColor;
					}
					this.numLabels = newNumElements;
				}
				else if (this.numLabels > newNumElements)
				{
					for (i = newNumElements; i < this.numLabels; i++)
					{
						this.labels[i] = null;
					}
					this.numLabels = newNumElements;
				}
			}


			AnimatedBTreeNode.prototype.left = function()
			{
				return this.x  - this.getWidth() / 2.0;
			}

			AnimatedBTreeNode.prototype.right = function()
			{
				return this.x  + this.getWidth() / 2.0;
			} 

			AnimatedBTreeNode.prototype.top = function()
			{
				return this.y - this.nodeHeight / 2.0;
			}

			AnimatedBTreeNode.prototype.bottom = function()
			{
				return this.y + this.nodeHeight / 2.0;
			}


			AnimatedBTreeNode.prototype.draw = function(context)
			{
				var startX;
				var startY;
				
				startX = this.left();
				if (startX == NaN)
				{
					startX  = 0;
				}
				startY = this.top();
				
				if (this.highlighted)
				{
					context.strokeStyle = "#ff0000";
					context.fillStyle = "#ff0000";
					
					context.beginPath();
					context.moveTo(startX - this.highlightDiff,startY- this.highlightDiff);
					context.lineTo(startX+this.getWidth() + this.highlightDiff,startY- this.highlightDiff);
					context.lineTo(startX+this.getWidth() + this.highlightDiff,startY+this.nodeHeight + this.highlightDiff);
					context.lineTo(startX - this.highlightDiff,startY+this.nodeHeight + this.highlightDiff);
					context.lineTo(startX - this.highlightDiff,startY - this.highlightDiff);				
					context.closePath();
					context.stroke();
					context.fill();
				}
				
				context.strokeStyle = this.foregroundColor;
				context.fillStyle = this.backgroundColor;
				
				context.beginPath();
				context.moveTo(startX ,startY);
				context.lineTo(startX + this.getWidth(), startY);
				context.lineTo(startX + this.getWidth(), startY + this.nodeHeight);
				context.lineTo(startX, startY + this.nodeHeight);
				context.lineTo(startX, startY);
				context.closePath();
				context.stroke();
				context.fill();
				
				context.textAlign = 'center';
				context.textBaseline   = 'middle'; 

				
				for (var i = 0; i < this.numLabels; i++)
				{
					var labelx  = this.x - this.widthPerElement * this.numLabels / 2 + this.widthPerElement / 2 + i * this.widthPerElement; 
					var labely = this.y			   

					context.fillStyle = this.labelColors[i];
					context.fillText(this.labels[i], labelx, labely); 
				}	
			}



			AnimatedBTreeNode.prototype.getHeight = function()
			{
				return this.nodeHeight;
			}



			AnimatedBTreeNode.prototype.setForegroundColor = function(newColor)
			{
				this.foregroundColor = newColor;
				for (var i = 0; i < numLabels; i++)
				{
					labelColor[i] = newColor;
				}
			}


			// TODO:  Kill the magic numbers here
			AnimatedBTreeNode.prototype.getTailPointerAttachPos = function(fromX, fromY, anchor)
			{
				if (anchor == 0)
				{
					return [this.left() + AnimatedBTreeNode.EDGE_POINTER_DISPLACEMENT, this.y];
				}
				else if (anchor == this.numLabels)
				{
					return [this.right() - AnimatedBTreeNode.EDGE_POINTER_DISPLACEMENT, this.y];	
				}
				else
				{
					return [this.left() + anchor * this.widthPerElement, this.y]
				}
			}


			AnimatedBTreeNode.prototype.getHeadPointerAttachPos = function(fromX, fromY)
			{
				if (fromY < this.y - this.nodeHeight / 2)
				{
					return [this.x, this.y - this.nodeHeight / 2];
				}
				else if (this.fromY > this.y + this.nodeHeight /  2)
				{
					return [this.x, this.y + this.nodeHeight / 2];			
				}
				else if (fromX  <  this.x  - this.getWidth() / 2)
				{
					return [this.x - this.getWidth() / 2, this.y];
				}
				else
				{
					return [this.x + this.getWidth() / 2, this.y];
				}
			}



			AnimatedBTreeNode.prototype.createUndoDelete = function()
			{
				return new UndoDeleteBTreeNode(this.objectID, this.numLabels, this.labels, this.x, this.y, this.widthPerElement, this.nodeHeight, this.labelColors, this.backgroundColor, this.foregroundColor, this.layer, this.highlighted);
			}


			AnimatedBTreeNode.prototype.getTextColor = function(textIndex)
			{
				textIndex = (textIndex == undefined) ? 0 : textIndex;
				return this.labelColors[textIndex];
			}

			AnimatedBTreeNode.prototype.getText = function(index)
			{
				index = (index == undefined) ? 0 : index;
				return this.labels[index];
			}

			AnimatedBTreeNode.prototype.setTextColor = function(color, textIndex)
			{
				textIndex = (textIndex == undefined) ? 0 : textIndex;
				this.labelColors[textIndex] = color;
			}


			AnimatedBTreeNode.prototype.setText = function(newText, textIndex)
			{
				textIndex = (textIndex == undefined) ? 0 : textIndex;
				this.labels[textIndex] = newText;
			}

					
					
			function UndoDeleteBTreeNode(id, numLab, labelText, x, y, wPerElement, nHeight, lColors, bgColor, fgColor, l, highlighted)
			{
				this.objectID = id;
				this.posX = x;
				this.posY = y;
				this.widthPerElem = wPerElement;
				this.nodeHeight = nHeight;
				this.backgroundColor= bgColor;
				this.foregroundColor = fgColor;
				this.numElems = numLab;
				this.labels = labelText;
				
				this.labelColors = lColors;
				this.layer = l;
				this.highlighted = highlighted;
			}
					
			UndoDeleteBTreeNode.prototype = new UndoBlock();
			UndoDeleteBTreeNode.prototype.constructor = UndoDeleteBTreeNode;
				
			UndoDeleteBTreeNode.prototype.undoInitialStep = function(world)
			{
				
				world.addBTreeNode(this.objectID, this.widthPerElem, this.nodeHeight, this.numElems, this.backgroundColor, this.foregroundColor);
				world.setNodePosition(this.objectID, this.posX, this.posY);
				for (var i = 0; i < this.numElems; i++)
				{
					world.setText(this.objectID, this.labels[i], i);
					world.setTextColor(this.objectID, this.labelColors[i],i);
				}
				world.setHighlight(this.objectID, this.highlighted);
				world.setLayer(this.objectID, this.layer);
			}

            // Object Manager
            function ObjectManager()
			{
				this.Nodes = [];
				this.Edges = [];
				this.BackEdges = [];
				this.activeLayers = [];
				this.activeLayers[0] = true;
				this.ctx = document.getElementById('canvas').getContext('2d');
				this.framenum = 0;
				this.width = 0;
				this.height = 0;
				this.statusReport = new AnimatedLabel(-1, "   ", false, 30);
				this.statusReport.x = 30;
				
				this.draw = function()
				{
					this.framenum++;
					if (this.framenum > 1000)
						this.framenum = 0;
					
					this.ctx.clearRect(0,0,this.width,this.height); // clear canvas
					this.statusReport.y = this.height - 15;
					
					var i;
					var j;
					for (i = 0; i < this.Nodes.length; i++)
					{
						if (this.Nodes[i] != null && !this.Nodes[i].highlighted && this.Nodes[i].addedToScene && !this.Nodes[i].alwaysOnTop)
						{
							this.Nodes[i].draw(this.ctx);	
						}
					}
					for (i = 0; i < this.Nodes.length; i++)
					{
						if (this.Nodes[i] != null && (this.Nodes[i].highlighted && !this.Nodes[i].alwaysOnTop) && this.Nodes[i].addedToScene)
						{
							this.Nodes[i].pulseHighlight(this.framenum);
							this.Nodes[i].draw(this.ctx);	
						}
					}
					
					for (i = 0; i < this.Nodes.length; i++)
					{
						if (this.Nodes[i] != null && this.Nodes[i].alwaysOnTop && this.Nodes[i].addedToScene)
						{
							this.Nodes[i].pulseHighlight(this.framenum);
							this.Nodes[i].draw(this.ctx);	
						}
					}
					
					
					for (i = 0; i < this.Edges.length; i++)
					{
						if (this.Edges[i] != null)
						{
							for (j = 0; j < this.Edges[i].length; j++)
							{
								if (this.Edges[i][j].addedToScene)
								{
									this.Edges[i][j].pulseHighlight(this.framenum);	
									this.Edges[i][j].draw(this.ctx);	
								}
								
							}
							
						}
					}
					this.statusReport.draw(this.ctx);
					
				}
				
				this.update = function ()
				{
					
					
				}
				
				
				this.setLayers = function(shown,layers)
				{
					for (var i = 0; i < layers.length; i++)
					{
						this.activeLayers[layers[i]] = shown;
					}
					this.resetLayers();
					
				}

				
				this.addHighlightCircleObject = function(objectID, objectColor, radius)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
							throw "addHighlightCircleObject:Object with same ID (" + String(objectID) + ") already Exists!"
					}
					var newNode = new HighlightCircle(objectID, objectColor, radius)
					this.Nodes[objectID] = newNode;		
				}
				
				this.setEdgeAlpha = function(fromID, toID, alphaVal)
				{
					var oldAlpha = 1.0; 
					if (this.Edges[fromID] != null &&
						this.Edges[fromID] != undefined)
					{
						var len = this.Edges[fromID].length;
						for (var i = len - 1; i >= 0; i--)
						{
							if (this.Edges[fromID][i] != null &&
								this.Edges[fromID][i] != undefined &&
								this.Edges[fromID][i].Node2 == this.Nodes[toID])
							{
								oldAlpha = this.Edges[fromID][i].alpha
								this.Edges[fromID][i].alpha = alphaVal;		
							}
						}
					}	
					return oldAlpha;
					
				}
				
				this.setAlpha = function(nodeID, alphaVal) 
				{
					if (this.Nodes[nodeID] != null && this.Nodes[nodeID] != undefined)
					{
						this.Nodes[nodeID].setAlpha(alphaVal);
					}
				}
				
				this.getAlpha = function(nodeID)
				{
					if (this.Nodes[nodeID] != null && this.Nodes[nodeID] != undefined)
					{
						return this.Nodes[nodeID].getAlpha();
					}
					else
					{
						return -1;
					}
				}
				
				this.getTextColor = function(nodeID, index)
				{
					if (this.Nodes[nodeID] != null && this.Nodes[nodeID] != undefined)
					{
						return this.Nodes[nodeID].getTextColor(index);
					}
					else
					{
						return "#000000";
					}
						
				}
				
				this.setTextColor = function(nodeID, color, index)
				{
					if (this.Nodes[nodeID] != null && this.Nodes[nodeID] != undefined)
					{
						this.Nodes[nodeID].setTextColor(color, index);
					}
				}


				this.setHighlightIndex = function(nodeID, index)
				{
					if (this.Nodes[nodeID] != null && this.Nodes[nodeID] != undefined)
					{
						this.Nodes[nodeID].setHighlightIndex(index);
					}
				}


				
				
				
				this.setAllLayers = function(layers)
				{
					this.activeLayers = [];
					for(var i = 0; i < layers.length; i++)
					{
						this.activeLayers[layers[i]] = true;
					}
					this.resetLayers();
				}
				
				this.resetLayers = function()
				{
					var i
					for (i = 0; i <this.Nodes.length; i++)
					{
						if (this.Nodes[i] != null && this.Nodes[i] != undefined)
						{
							this.Nodes[i].addedToScene = this.activeLayers[this.Nodes[i].layer] == true;
						}
					}
					for (i = this.Edges.length - 1; i >= 0; i--)
					{
						if (this.Edges[i] != null && this.Edges[i] != undefined)
						{
							for (var j = 0; j < this.Edges[i].length; j++)
							{
								if (this.Edges[i][j] != null && this.Edges[i][j] != undefined)
								{
										this.Edges[i][j].addedToScene =
											this.activeLayers[this.Edges[i][j].Node1.layer] == true &&
											this.activeLayers[this.Edges[i][j].Node2.layer] == true;
								}
								
							}
							
						}
						
					}
					
				}
				
				
				
				this.setLayer = function(objectID, layer)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
						this.Nodes[objectID].layer = layer;
						if (this.activeLayers[layer])
						{
							this.Nodes[objectID].addedToScene = true;
						}
						else
						{
							this.Nodes[objectID].addedToScene = false;
						}
						if (this.Edges[objectID] != null && this.Edges[objectID] != undefined)
						{
							for (var i = 0; i < this.Edges[objectID].length; i++)
							{
								var nextEdge = this.Edges[objectID][i];
								if (nextEdge != null && nextEdge != undefined)
								{
									nextEdge.addedToScene = ((nextEdge.Node1.addedToScene) &&
															(nextEdge.Node2.addedToScene));
									
								}
							}
						}
						if (this.BackEdges[objectID] != null && this.BackEdges[objectID] != undefined)
						{
							for (var i = 0; i < this.BackEdges[objectID].length; i++)
							{
								var nextEdge = this.BackEdges[objectID][i];
								if (nextEdge != null && nextEdge != undefined)
								{
									nextEdge.addedToScene = ((nextEdge.Node1.addedToScene) &&
															(nextEdge.Node2.addedToScene));
									
								}
							}
						}			
					}
				}
				
				this.clearAllObjects = function()
				{
					this.Nodes = [];
					this.Edges = [];
					this.BackEdges = [];
				}
				
				
				this.setForegroundColor = function(objectID, color)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
						this.Nodes[objectID].setForegroundColor(color);
						
					}
				}
				
				this.setBackgroundColor = function(objectID, color)
				{
					if (this.Nodes[objectID] != null)
					{
						this.Nodes[objectID].setBackgroundColor(color);
						
					}
				}
				
				this.setHighlight = function(nodeID, val)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return;
					}
					this.Nodes[nodeID].setHighlight(val);
				}
				
				
				this.getHighlight = function(nodeID)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return false;
					}
					return this.Nodes[nodeID].getHighlight();
				}


				this.getHighlightIndex = function(nodeID)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return false;
					}
					return this.Nodes[nodeID].getHighlightIndex();
				}
				
				this.setWidth = function(nodeID, val)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return;
					}
					this.Nodes[nodeID].setWidth(val);
				}
				
				this.setHeight = function(nodeID, val)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return;
					}
					this.Nodes[nodeID].setHeight(val);
				}
				
				
				this.getHeight = function(nodeID)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return -1;
					}
					return this.Nodes[nodeID].getHeight();
				}
				
				this.getWidth = function(nodeID)
				{
					if (this.Nodes[nodeID] == null  || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return -1;
					}
					return this.Nodes[nodeID].getWidth();
				}
				
				this.backgroundColor = function(objectID)
				{
					if (this.Nodes[objectID] != null)
					{
						return this.Nodes[objectID].backgroundColor;
					}
					else
					{
						return '#000000';
					}
				}
				
				this.foregroundColor = function(objectID)
				{
					if (this.Nodes[objectID] != null)
					{
						return this.Nodes[objectID].foregroundColor;
					}
					else
					{
						return '#000000';
					}
				}
				
						
				this.disconnect = function(objectIDfrom,objectIDto)
				{
					var undo = null;
					var i;
					if (this.Edges[objectIDfrom] != null)
					{
						var len = this.Edges[objectIDfrom].length;
						for (i = len - 1; i >= 0; i--)
						{
							if (this.Edges[objectIDfrom][i] != null && this.Edges[objectIDfrom][i].Node2 == this.Nodes[objectIDto])
							{
								var deleted = this.Edges[objectIDfrom][i];
								undo = deleted.createUndoDisconnect();
								this.Edges[objectIDfrom][i] = this.Edges[objectIDfrom][len - 1];
								len -= 1;
								this.Edges[objectIDfrom].pop();
							}
						}
					}
					if (this.BackEdges[objectIDto] != null)
					{
						len = this.BackEdges[objectIDto].length;
						for (i = len - 1; i >= 0; i--)
						{
							if (this.BackEdges[objectIDto][i] != null && this.BackEdges[objectIDto][i].Node1 == this.Nodes[objectIDfrom])
							{
								deleted = this.BackEdges[objectIDto][i];
								// Note:  Don't need to remove this child, did it above on the regular edge
								this.BackEdges[objectIDto][i] = this.BackEdges[objectIDto][len - 1];
								len -= 1;
								this.BackEdges[objectIDto].pop();
							}
						}
					}
					return undo;
				}
				
				this.deleteIncident = function(objectID)
				{
					var undoStack = [];

					if (this.Edges[objectID] != null)
					{
						var len = this.Edges[objectID].length;
						for (var i = len - 1; i >= 0; i--)
						{
							var deleted = this.Edges[objectID][i];
							var node2ID = deleted.Node2.identifier();
							undoStack.push(deleted.createUndoDisconnect());
							
							var len2 = this.BackEdges[node2ID].length;
							for (var j = len2 - 1; j >=0; j--)
							{
								if (this.BackEdges[node2ID][j] == deleted)
								{
									this.BackEdges[node2ID][j] = this.BackEdges[node2ID][len2 - 1];
									len2 -= 1;
									this.BackEdges[node2ID].pop();
								}
							}
						}
						this.Edges[objectID] = null;
					}
					if (this.BackEdges[objectID] != null)
					{
						len = this.BackEdges[objectID].length;
						for (i = len - 1; i >= 0; i--)
						{
							deleted = this.BackEdges[objectID][i];
							var node1ID = deleted.Node1.identifier();
							undoStack.push(deleted.createUndoDisconnect());

							len2 = this.Edges[node1ID].length;
							for (j = len2 - 1; j >=0; j--)
							{
								if (this.Edges[node1ID][j] == deleted)
								{
									this.Edges[node1ID][j] = this.Edges[node1ID][len2 - 1];
									len2 -= 1;
									this.Edges[node1ID].pop();
								}
							}
						}
						this.BackEdges[objectID] = null;
					}
					return undoStack;
				}
				
				
				this.removeObject = function(ObjectID)
				{
					var OldObject = this.Nodes[ObjectID];
					if (ObjectID == this.Nodes.length - 1)
					{
						this.Nodes.pop();
					}
					else
					{
						this.Nodes[ObjectID] = null;
					}
				}
				
				this.getObject = function(objectID)
				{
					if (this.Nodes[objectID] == null || this.Nodes[objectID] == undefined)
					{
						throw "getObject:Object with ID (" + String(objectID) + ") does not exist"
					}
					return this.Nodes[objectID];
					
				}
				
				
				this.addCircleObject = function (objectID, objectLabel)
				{
						if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
						{
							throw "addCircleObject:Object with same ID (" + String(objectID) + ") already Exists!"
						}
						var newNode = new AnimatedCircle(objectID, objectLabel);
						this.Nodes[objectID] = newNode;
				}
				
				this.getNodeX = function(nodeID)
				{
					if (this.Nodes[nodeID] == null || this.Nodes[nodeID] == undefined)
					{
						throw "getting x position of an object that does not exit";
					}	
					return this.Nodes[nodeID].x;
				}
				
				this.getTextWidth = function(text)
				{
					// TODO:  Need to make fonts more flexible, and less hardwired.
					this.ctx.font = '12px sans-serif';
					if (text==undefined)
					{
						w = 3;
					}
					var strList = text.split("\n");
					var width = 0;
					if (strList.length == 1)
					{
						width = this.ctx.measureText(text).width;
					}
					else
					{
						for (var i = 0; i < strList.length; i++)
						{
							width = Math.max(width, this.ctx.measureText(strList[i]).width);
						}		
					}
					
					return width;
				}
				
				this.setText = function(nodeID, text, index)
				{
					if (this.Nodes[nodeID] == null || this.Nodes[nodeID] == undefined)
					{
						return;
						throw "setting text of an object that does not exit";
					}			
					this.Nodes[nodeID].setText(text, index, this.getTextWidth(text));
					
				}
				
				this.getText = function(nodeID, index)
				{
					if (this.Nodes[nodeID] == null || this.Nodes[nodeID] == undefined)
					{
						throw "getting text of an object that does not exit";
					}			
					return this.Nodes[nodeID].getText(index);
					
				}
				
				this.getNodeY = function(nodeID)
				{
					if (this.Nodes[nodeID] == null || this.Nodes[nodeID] == undefined)
					{
						throw "getting y position of an object that does not exit";
					}	
					return this.Nodes[nodeID].y;
				}

				
				this.connectEdge = function(objectIDfrom, objectIDto, color, curve, directed, lab, connectionPoint)
				{
					var fromObj = this.Nodes[objectIDfrom];
					var toObj = this.Nodes[objectIDto];
					if (fromObj == null || toObj == null)
					{
						throw "Tried to connect two nodes, one didn't exist!";
					}
					var l = new Line(fromObj,toObj, color, curve, directed, lab, connectionPoint);
					if (this.Edges[objectIDfrom] == null || this.Edges[objectIDfrom] == undefined)
					{
						this.Edges[objectIDfrom] = [];
					}
					if (this.BackEdges[objectIDto] == null || this.BackEdges[objectIDto] == undefined)
					{
						this.BackEdges[objectIDto] = [];
					}
					l.addedToScene = fromObj.addedToScene && toObj.addedToScene;
					this.Edges[objectIDfrom].push(l);
					this.BackEdges[objectIDto].push(l);
					
				}
				
				
				this.setNull = function(objectID, nullVal)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
						this.Nodes[objectID].setNull(nullVal);
						
					}
				}
				
				this.getNull = function(objectID)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
						return this.Nodes[objectID].getNull();
					}
					return false;  // TODO:  Error here?
				}
				
				
				
				this.setEdgeColor = function(fromID, toID, color) // returns old color
				{
					var oldColor ="#000000";
					if (this.Edges[fromID] != null &&
						this.Edges[fromID] != undefined)
					{
						var len = this.Edges[fromID].length;
						for (var i = len - 1; i >= 0; i--)
						{
							if (this.Edges[fromID][i] != null &&
								this.Edges[fromID][i] != undefined &&
								this.Edges[fromID][i].Node2 == this.Nodes[toID])
							{
								oldColor = this.Edges[fromID][i].color();
								this.Edges[fromID][i].setColor(color);		
							}
						}
					}	
					return oldColor;
				}		
				
				this.alignTop = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
					this.Nodes[id1].alignTop(this.Nodes[id2]);
				}
				
				this.alignLeft = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
					this.Nodes[id1].alignLeft(this.Nodes[id2]);
				}
				
				this.alignRight = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
					this.Nodes[id1].alignRight(this.Nodes[id2]);
				}
				


				this.getAlignRightPos = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
						return this.Nodes[id1].getAlignRightPos(this.Nodes[id2]);
				}

				this.getAlignLeftPos = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
						return this.Nodes[id1].getAlignLeftPos(this.Nodes[id2]);
				}
				


				this.alignBottom = function(id1, id2)
				{
					if (this.Nodes[id1] == null || this.Nodes[id1] == undefined ||
						this.Nodes[id2] == null || this.Nodes[id2] == undefined)
					{
						throw "Tring to align two nodes, one doesn't exist: " + String(id1) + "," + String(id2);			
					}
					this.Nodes[id1].alignBottom(this.Nodes[id2]);
				}
				
				
				this.setEdgeHighlight = function(fromID, toID, val) // returns old color
				{
					var oldHighlight = false;
					if (this.Edges[fromID] != null &&
						this.Edges[fromID] != undefined)
					{
						var len = this.Edges[fromID].length;
						for (var i = len - 1; i >= 0; i--)
						{
							if (this.Edges[fromID][i] != null && 
								this.Edges[fromID][i] != undefined && 
								this.Edges[fromID][i].Node2 == this.Nodes[toID])
							{
								oldHighlight = this.Edges[fromID][i].highlighted;
								this.Edges[fromID][i].setHighlight(val);		
							}
						}
					}
					return oldHighlight;
				}
				this.addLabelObject = function(objectID, objectLabel, centering)
				{
					if (this.Nodes[objectID] != null && this.Nodes[objectID] != undefined)
					{
						throw new Error("addLabelObject: Object Already Exists!");
					}
					
					var newLabel = new AnimatedLabel(objectID, objectLabel, centering, this.getTextWidth(objectLabel));
					this.Nodes[objectID] = newLabel;
				}
				
					
				this.addLinkedListObject = function(objectID, nodeLabel, width, height, linkPer, verticalOrientation, linkPosEnd, numLabels, backgroundColor, foregroundColor)
				{
					if (this.Nodes[objectID] != null)
					{
						throw new Error("addLinkedListObject:Object with same ID already Exists!");
						return;
					}
					var newNode  = new AnimatedLinkedList(objectID, nodeLabel, width, height, linkPer, verticalOrientation, linkPosEnd, numLabels, backgroundColor, foregroundColor);
					this.Nodes[objectID] = newNode;
				}
				
				
				this.getNumElements = function(objectID)
				{
					return this.Nodes[objectID].getNumElements();
				}
				
				
				this.setNumElements = function(objectID, numElems)
				{
					this.Nodes[objectID].setNumElements(numElems);
				}
				this.addBTreeNode = function(objectID, widthPerElem, height, numElems, backgroundColor, foregroundColor)
				{
					backgroundColor = (backgroundColor == undefined) ? "#FFFFFF" : backgroundColor;
					foregroundColor = (foregroundColor == undefined) ? "#FFFFFF" : foregroundColor;
					
					if (this.Nodes[objectID] != null && Nodes[objectID] != undefined)
					{
						throw "addBTreeNode:Object with same ID already Exists!";
					}

					var newNode = new AnimatedBTreeNode(objectID,widthPerElem, height, numElems, backgroundColor, foregroundColor);
					this.Nodes[objectID] = newNode;
				}
				
				this.addRectangleObject = function(objectID,nodeLabel, width, height, xJustify , yJustify , backgroundColor, foregroundColor)
				{
					if (this.Nodes[objectID] != null || this.Nodes[objectID] != undefined)
					{
						throw new Error("addRectangleObject:Object with same ID already Exists!");
					}
					var newNode = new AnimatedRectangle(objectID, nodeLabel, width, height, xJustify, yJustify, backgroundColor, foregroundColor);
					this.Nodes[objectID] = newNode;
					
				}
				
				
				
				
				this.setNodePosition = function(nodeID, newX, newY)
				{
					if (this.Nodes[nodeID] == null || this.Nodes[nodeID] == undefined)
					{
						// TODO:  Error here?
						return;
					}
					if (newX == undefined || newY == undefined)
					{
						
						return;
					}
					this.Nodes[nodeID].x = newX;
					this.Nodes[nodeID].y = newY;
					/* Don't need to dirty anything, since we repaint everything every frame
					(TODO:  Revisit if we do conditional redraws)
					}*/
					
				}
				
			}

            // Animation Main
            var timer;
			var swapped = false;


			function reorderSibling(node1, node2) 
			{
				node1.parentNode.replaceChild(node1, node2);
				node1.parentNode.insertBefore(node2, node1); 
			}


			function swapControlDiv()
			{
				swapped = !swapped;
				if (swapped) {
					reorderSibling(document.getElementById('canvas'), document.getElementById('generalAnimationControlSection'));
					setCookie("VisualizationControlSwapped", "true", 30);

				} else {
					reorderSibling(document.getElementById('generalAnimationControlSection'), document.getElementById('canvas'));
					setCookie("VisualizationControlSwapped", "false", 30);
				}
			}


			// Utility funciton to read a cookie
			function getCookie(cookieName)
			{
				var i, x, y;
				var cookies=document.cookie.split(";");
				for (i=0; i < cookies.length; i++)
				{
					x=cookies[i].substr(0,cookies[i].indexOf("="));
					y=cookies[i].substr(cookies[i].indexOf("=")+1);
					x=x.replace(/^\s+|\s+$/g,"");
					if (x==cookieName)
					{
						return unescape(y);
					}
				}
			}

			// Utility funciton to write a cookie
			function setCookie(cookieName,value,expireDays)
			{
				var exdate=new Date();
				exdate.setDate(exdate.getDate() + expireDays);
				var cookieValue=escape(value) + ((expireDays==null) ? "" : "; expires="+exdate.toUTCString());
				document.cookie=cookieName + "=" + value;
			}


			var ANIMATION_SPEED_DEFAULT = 75;


			// TODO:  Move these out of global space into animation manager?
			var objectManager;
			var animationManager;
			var canvas;

			var paused = false;
			var playPauseBackButton;
			var skipBackButton;
			var stepBackButton;
			var stepForwardButton;
			var skipForwardButton;

			var widthEntry;
			var heightEntry;
			var sizeButton;



			function returnSubmit(field, funct, maxsize, intOnly)
			{
				
				if (maxsize != undefined)
				{
					field.size = maxsize;
				}
				return function(event)
				{       
					var keyASCII = 0;
					if(window.event) // IE
					{
						keyASCII = event.keyCode
					}
					else if (event.which) // Netscape/Firefox/Opera
					{
						keyASCII = event.which
					} 

					if (keyASCII == 13)
					{
						funct();
									return false;
					}
						else if (keyASCII == 59  || keyASCII == 45 || keyASCII == 46 || keyASCII == 190 || keyASCII == 173)
					{
						return false;	
					} 
					else if (maxsize != undefined && field.value.length >= maxsize ||
							intOnly && (keyASCII < 48 || keyASCII > 57))

					{
						if (!controlKey(keyASCII))
							return false;
					}
					return true;
					
				}
				
			}


			function animWaiting()
			{
				stepForwardButton.disabled = false;
				if (skipBackButton.disabled == false)
				{
					stepBackButton.disabled = false;
				}
				//objectManager.statusReport.setText("Animation Paused");
				objectManager.statusReport.setForegroundColor("#FF0000");
			}

			function animStarted()
			{/*
				skipForwardButton.disabled = false;
				skipBackButton.disabled = false;
				stepForwardButton.disabled = true;
				stepBackButton.disabled = true;
				//objectManager.statusReport.setText("Animation Running");
				*/
				objectManager.statusReport.setForegroundColor("#009900");
			}

			function animEnded()
			{/*
				skipForwardButton.disabled = true;
				stepForwardButton.disabled = true;
				if (skipBackButton.disabled == false && paused)
				{
					stepBackButton.disabled = false;		
				}
				*/
				//objectManager.statusReport.setText("Animation Completed");
				objectManager.statusReport.setForegroundColor("#000000");
			}



			function anumUndoUnavailable()
			{
				/*
				skipBackButton.disabled = true;
				stepBackButton.disabled = true;
				*/
			}


			function timeout()
			{
				// We need to set the timeout *first*, otherwise if we
				// try to clear it later, we get behavior we don't want ...
				timer = setTimeout('timeout()', 30); 
				animationManager.update();
				objectManager.draw();	
					
			}


			function doStep()
			{
				animationManager.step();
			}


			function doSkip()
			{
				animationManager.skipForward();
			}


			function doSkipBack()
			{
				animationManager.skipBack();
			}


			function doStepBack()
			{
				animationManager.stepBack();
			}
			function doPlayPause()
			{
				paused = !paused;
				if (paused)
				{
					playPauseBackButton.setAttribute("value", "play");
					if (skipBackButton.disabled == false)
					{
						stepBackButton.disabled = false;		
					}
					
				}
				else
				{
					playPauseBackButton.setAttribute("value", "pause");	
				}
				animationManager.SetPaused(paused);
			}


			function addControl(type, name, location) {
				
				var element = document.createElement("input");
				
				element.setAttribute("type", type);
				element.setAttribute("value", name);

				var tableEntry = document.createElement("td");
				
				tableEntry.appendChild(element);
				
				
				var controlBar = document.getElementById(tableEntry);
				
				//Append the element in page (in span).
				controlBar.appendChild(element);
				return element;
			
			}

			function addControlToAnimationBar(type,name,containerType)
			{
				if (containerType == undefined)
				{
						containerType = "input";
				}
				var element = document.createElement(containerType);
				
					element.setAttribute("type", type);
					element.setAttribute("value", name);
				
				
				var tableEntry = document.createElement("td");
				
				tableEntry.appendChild(element);
				
				var controlBar = document.getElementById("GeneralAnimationControls");
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
				return element;
				
			}


			function initCanvas()
			{
				canvas =  document.getElementById("canvas");
				objectManager = new ObjectManager();
				animationManager = new AnimationManager(objectManager);
				/*
				skipBackButton = addControlToAnimationBar("Button", "Skip Back");
				skipBackButton.onclick = animationManager.skipBack.bind(animationManager);
				stepBackButton = addControlToAnimationBar("Button", "Step Back");
				stepBackButton.onclick = animationManager.stepBack.bind(animationManager);
				playPauseBackButton = addControlToAnimationBar("Button", "Pause");
				playPauseBackButton.onclick = doPlayPause ;
				stepForwardButton = addControlToAnimationBar("Button", "Step Forward");
				stepForwardButton.onclick = animationManager.step.bind(animationManager) ;
				skipForwardButton = addControlToAnimationBar("Button", "Skip Forward");
				skipForwardButton.onclick = animationManager.skipForward.bind(animationManager);
				*/
				
				var element = document.createElement("div");
				element.setAttribute("display", "inline-block");		
				element.setAttribute("float", "left");		

				
				var tableEntry = document.createElement("td");
				
				
				var controlBar = document.getElementById("GeneralAnimationControls");
				
				
				
				var newTable = document.createElement("table");

				var midLevel = document.createElement("tr");
				var bottomLevel = document.createElement("td");
				midLevel.appendChild(bottomLevel);
				bottomLevel.appendChild(element);
				newTable.appendChild(midLevel);	
				
				tableEntry.appendChild(newTable);
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
					
				//tableEntry.appendChild(element);

				var speed = getCookie("VisualizationSpeed");
				if (speed == null || speed == "")
				{
					speed = ANIMATION_SPEED_DEFAULT;
				}
				else
				{
					speed = parseInt(speed);
				}
				/*
				$(element).slider({
								animate: true,
								value: speed,
								change: function(e, ui)
								{
									setCookie("VisualizationSpeed", String(ui.value), 30);
								},
								slide : function(e, ui){
								animationManager.SetSpeed(ui.value); 
								}

								}); 
				*/
				animationManager.SetSpeed(speed);
				
				element.setAttribute("style", "width:200px");



				var width=getCookie("VisualizationWidth");
				if (width == null || width == "")
				{
					width = canvas.width;
				}
				else
				{
					width = parseInt(width);
				}
				var height=getCookie("VisualizationHeight");
				if (height == null || height == "")
				{
					height = canvas.height;
				}
				else
				{
					height = parseInt(height);
				}

				var swappedControls=getCookie("VisualizationControlSwapped");
				swapped = true;//swappedControls == "false"
				if (swapped)
				{
					reorderSibling(document.getElementById('canvas'), document.getElementById('generalAnimationControlSection'));
				}

				canvas.width = width;
				canvas.height = height;
				tableEntry = document.createElement("td");
				txtNode = document.createTextNode(" w:"); 
				tableEntry.appendChild(txtNode);
				controlBar.appendChild(tableEntry);
				widthEntry = addControlToAnimationBar("Text", canvas.width);
				widthEntry.size = 4;
				widthEntry.onkeydown = this.returnSubmit(widthEntry, animationManager.changeSize.bind(animationManager), 4, true);

				
				tableEntry = document.createElement("td");
				txtNode = document.createTextNode("       h:"); 
				tableEntry.appendChild(txtNode);
				controlBar.appendChild(tableEntry);
				
				heightEntry = addControlToAnimationBar("Text", canvas.height);
				heightEntry.onkeydown = this.returnSubmit(heightEntry, animationManager.changeSize.bind(animationManager), 4, true);

			//	heightEntry.size = 4;
				sizeButton = addControlToAnimationBar("Button", "Cambiar el tamaño del área de dibujo");
				
				sizeButton.onclick = animationManager.changeSize.bind(animationManager) ;
				/*

				swapButton = addControlToAnimationBar("Button", "Move Controls");
				swapButton.onclick = swapControlDiv;	
				*/
				
				animationManager.addListener("AnimationStarted", this, animStarted);
				animationManager.addListener("AnimationEnded", this, this.animEnded);
				animationManager.addListener("AnimationWaiting", this, this.animWaiting);
				animationManager.addListener("AnimationUndoUnavailable", this, this.anumUndoUnavailable);
				objectManager.width = canvas.width;
				objectManager.height = canvas.height;
				return animationManager;
			}



			function AnimationManager(objectManager)
			{
				// Holder for all animated objects.
				// All animation is done by manipulating objects in\
				// this container
				this.animatedObjects = objectManager;

				// Control variables for stopping / starting animation
				
				this.animationPaused = false;
				this.awaitingStep = false;
				this.currentlyAnimating = false;
				
				// Array holding the code for the animation.  This is 
				// an array of strings, each of which is an animation command
				// currentAnimation is an index into this array
				this.AnimationSteps = [];
				this.currentAnimation = 0;
				
				this.previousAnimationSteps = [];
				
				// Control variables for where we are in the current animation block.
				//  currFrame holds the frame number of the current animation block,
				//  while animationBlockLength holds the length of the current animation
				//  block (in frame numbers).  
				this.currFrame = 0;
				this.animationBlockLength = 0;
				
				//  The animation block that is currently running.  Array of singleAnimations
				this.currentBlock = null;
				
				/////////////////////////////////////
				// Variables for handling undo. 
				////////////////////////////////////
				//  A stack of UndoBlock objects (subclassed, UndoBlock is an abstract base class)
				//  each of which can undo a single animation element
				this.undoStack = [];
				this.doingUndo = false;
				
				// A stack containing the beginning of each animation block, as an index
				// into the AnimationSteps array
				this.undoAnimationStepIndices = [];
				this.undoAnimationStepIndicesStack = [];
				
				this.animationBlockLength = 10;

				this.lerp = function(from, to, percent)
				{
					return (to - from) * percent + from;
				}
				
				// Pause / unpause animation
				this.SetPaused = function(pausedValue)
				{
					this.animationPaused = pausedValue;
					if (!this.animationPaused)
					{
						this.step();
					}
				}
				
				// Set the speed of the animation, from 0 (slow) to 100 (fast)
				this.SetSpeed = function(newSpeed)
				{
					this.animationBlockLength = Math.floor((100-newSpeed) / 2);
				}
				

				this.parseBool = function(str)
				{
					var uppercase = str.toUpperCase();
					var returnVal =  !(uppercase == "False" || uppercase == "f" || uppercase == " 0" || uppercase == "0" || uppercase == "");
					return returnVal;

				}

				this.parseColor = function(clr)
				{
						if (clr.charAt(0) == "#")
						{
							return clr;
						}
						else if (clr.substring(0,2) == "0x")
						{
							return "#" + clr.substring(2);
						}
				}
				
				
				this.changeSize = function()
				{
					
					var width = parseInt(widthEntry.value);
					var height = parseInt(heightEntry.value);
					
					if (width > 100)
					{
						canvas.width = width;
						this.animatedObjects.width = width;
						setCookie("VisualizationWidth", String(width), 30);
						
					}
					if (height > 100)
					{
						canvas.height = height;
						this.animatedObjects.height = height;
						setCookie("VisualizationHeight", String(height), 30);
					}
					width.value = canvas.width;
					heightEntry.value = canvas.height;
					
					this.animatedObjects.draw();
					this.fireEvent("CanvasSizeChanged",{width:canvas.width, height:canvas.height});		
				}
				
				this.startNextBlock = function()
				{
					this.awaitingStep = false;
					this.currentBlock = [];
					var undoBlock = []
					if (this.currentAnimation == this.AnimationSteps.length )
					{
						this.currentlyAnimating = false;
						this.awaitingStep = false;
						this.fireEvent("AnimationEnded","NoData");
						clearTimeout(timer);
						this.animatedObjects.update();
						this.animatedObjects.draw();
						
						return;
					}
					this.undoAnimationStepIndices.push(this.currentAnimation);

					var foundBreak= false;
					var anyAnimations= false;
					
					while (this.currentAnimation < this.AnimationSteps.length && !foundBreak)
					{			
						var nextCommand = this.AnimationSteps[this.currentAnimation].split("<;>");
						if (nextCommand[0].toUpperCase() == "CREATECIRCLE")
						{
							this.animatedObjects.addCircleObject(parseInt(nextCommand[1]), nextCommand[2]);
							if (nextCommand.length > 4)
							{
								this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseInt(nextCommand[3]), parseInt(nextCommand[4]));
							}
							undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));

						}
						else if (nextCommand[0].toUpperCase() == "CONNECT")
						{
							
							if (nextCommand.length > 7)
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]), 
																					parseInt(nextCommand[2]), 
																					this.parseColor(nextCommand[3]), 
																					parseFloat(nextCommand[4]), 
																					this.parseBool(nextCommand[5]), 
																					nextCommand[6], 
																					parseInt(nextCommand[7]));
							}
							else if (nextCommand.length > 6)
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]), 
																					parseInt(nextCommand[2]),
																					this.parseColor(nextCommand[3]),
																					parseFloat(nextCommand[4]),
																					this.parseBool(nextCommand[5]),
																					nextCommand[6],
																					0);
							}
							else if (nextCommand.length > 5)
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]), 
																					parseInt(nextCommand[2]),
																					this.parseColor(nextCommand[3]),
																					parseFloat(nextCommand[4]),
																					this.parseBool(nextCommand[5]),
																					"",
																					0);
							}
							else if (nextCommand.length > 4)
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]),
																					parseInt(nextCommand[2]),
																					this.parseColor(nextCommand[3]),
																					parseFloat(nextCommand[4]),
																					true,
																					"",
																					0);
							}
							else if (nextCommand.length > 3)
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]),
																					parseInt(nextCommand[2]),
																					this.parseColor(nextCommand[3]),
																					0.0,
																					true,
																					"",
																					0);
							}
							else
							{
								this.animatedObjects.connectEdge(parseInt(nextCommand[1]),
																					parseInt(nextCommand[2]),
																					"#000000",
																					0.0,
																					true,
																					"",
																					0);
								
							}
							undoBlock.push(new UndoConnect(parseInt(nextCommand[1]), parseInt (nextCommand[2]), false));
						}
						else if (nextCommand[0].toUpperCase() == "CREATERECTANGLE")
						{
							if (nextCommand.length == 9)
							{
								this.animatedObjects.addRectangleObject(parseInt(nextCommand[1]), // ID
																		nextCommand[2], // Label
																		parseInt(nextCommand[3]), // w
																		parseInt(nextCommand[4]), // h
																		nextCommand[7], // xJustify
																		nextCommand[8],// yJustify
																		"#ffffff", // background color
																		"#000000"); // foreground color
							}
							else
							{
								this.animatedObjects.addRectangleObject(parseInt(nextCommand[1]), // ID
																		nextCommand[2], // Label
																		parseInt(nextCommand[3]), // w
																		parseInt(nextCommand[4]), // h
																		"center", // xJustify
																		"center",// yJustify
																		"#ffffff", // background color
																		"#000000"); // foreground color
								
							}
							if (nextCommand.length > 6)
							{
								this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseInt(nextCommand[5]), parseInt(nextCommand[6]));
							}
							undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));
						}
						
						else if (nextCommand[0].toUpperCase() == "MOVE")
						{
							var objectID = parseInt(nextCommand[1]);
							var nextAnim =  new SingleAnimation(objectID, 
																this.animatedObjects.getNodeX(objectID), 
																this.animatedObjects.getNodeY(objectID), 
																parseInt(nextCommand[2]),
																parseInt(nextCommand[3]));
							this.currentBlock.push(nextAnim);

							undoBlock.push(new UndoMove(nextAnim.objectID, nextAnim.toX, nextAnim.toY, nextAnim.fromX, nextAnim.fromY));

							anyAnimations = true;
						}
						
						else if (nextCommand[0].toUpperCase() == "MOVETOALIGNRIGHT")
						{
							var id = parseInt(nextCommand[1]);
							var otherId = parseInt(nextCommand[2]);
											var newXY = this.animatedObjects.getAlignRightPos(id, otherId);


							var nextAnim =  new SingleAnimation(id,
												this.animatedObjects.getNodeX(id), 
												this.animatedObjects.getNodeY(id), 
												newXY[0],
												newXY[1]);
							this.currentBlock.push(nextAnim);
							undoBlock.push(new UndoMove(nextAnim.objectID, nextAnim.toX, nextAnim.toY, nextAnim.fromX, nextAnim.fromY));
							anyAnimations = true;
						}

						else if (nextCommand[0].toUpperCase() == "STEP")
						{
							foundBreak = true;
						}
						else if (nextCommand[0].toUpperCase() == "SETFOREGROUNDCOLOR")
						{
							var id = parseInt(nextCommand[1]);
							var oldColor = this.animatedObjects.foregroundColor(id);
							this.animatedObjects.setForegroundColor(id, this.parseColor(nextCommand[2]));
							undoBlock.push(new UndoSetForegroundColor(id, oldColor));
						}
						else if (nextCommand[0].toUpperCase() == "SETBACKGROUNDCOLOR")
						{
							id = parseInt(nextCommand[1]);
							oldColor = this.animatedObjects.backgroundColor(id);
							this.animatedObjects.setBackgroundColor(id, this.parseColor(nextCommand[2]));
							undoBlock.push(new UndoSetBackgroundColor(id, oldColor));
						}
						else if (nextCommand[0].toUpperCase() == "SETHIGHLIGHT")
						{
							var newHighlight = this.parseBool(nextCommand[2]);
							this.animatedObjects.setHighlight( parseInt(nextCommand[1]), newHighlight);
							undoBlock.push(new UndoHighlight( parseInt(nextCommand[1]), !newHighlight));
						}
						else if (nextCommand[0].toUpperCase() == "DISCONNECT")
						{
							var undoConnect = this.animatedObjects.disconnect(parseInt(nextCommand[1]), parseInt(nextCommand[2]));
							if (undoConnect != null)
							{
								undoBlock.push(undoConnect);
							}
						}
						else if (nextCommand[0].toUpperCase() == "SETALPHA")
						{
							var oldAlpha = this.animatedObjects.getAlpha(parseInt(nextCommand[1]));
							this.animatedObjects.setAlpha(parseInt(nextCommand[1]), parseFloat(nextCommand[2]));
							undoBlock.push(new UndoSetAlpha(parseInt(nextCommand[1]), oldAlpha));					
						}
						else if (nextCommand[0].toUpperCase() == "SETTEXT")
						{
							if (nextCommand.length > 3)
							{
								var oldText = this.animatedObjects.getText(parseInt(nextCommand[1]), parseInt(nextCommand[3]));
								this.animatedObjects.setText(parseInt(nextCommand[1]), nextCommand[2], parseInt(nextCommand[3]));
								if (oldText != undefined)
								{
									undoBlock.push(new UndoSetText(parseInt(nextCommand[1]), oldText, parseInt(nextCommand[3]) ));			
								}	
							}
							else
							{
								oldText = this.animatedObjects.getText(parseInt(nextCommand[1]), 0);
								this.animatedObjects.setText(parseInt(nextCommand[1]), nextCommand[2], 0);
								if (oldText != undefined)
								{
									undoBlock.push(new UndoSetText(parseInt(nextCommand[1]), oldText, 0));	
								}
							}
						}
						else if (nextCommand[0].toUpperCase() == "DELETE")
						{
							var objectID  = parseInt(nextCommand[1]);
							
							var i;
							var removedEdges = this.animatedObjects.deleteIncident(objectID);
							if (removedEdges.length > 0)
							{
								undoBlock = undoBlock.concat(removedEdges);
							}
							var obj = this.animatedObjects.getObject(objectID);
							if (obj != null)
							{
								undoBlock.push(obj.createUndoDelete());
								this.animatedObjects.removeObject(objectID);
							}
						}
						else if (nextCommand[0].toUpperCase() == "CREATEHIGHLIGHTCIRCLE")
						{
							if (nextCommand.length > 5)
							{
								this.animatedObjects.addHighlightCircleObject(parseInt(nextCommand[1]), this.parseColor(nextCommand[2]), parseFloat(nextCommand[5]));
							}
							else
							{
								this.animatedObjects.addHighlightCircleObject(parseInt(nextCommand[1]), this.parseColor(nextCommand[2]), 20);						
							}
							if (nextCommand.length > 4)
							{
								this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseInt(nextCommand[3]), parseInt(nextCommand[4]));
							}
							undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));
							
							
						}
						else if (nextCommand[0].toUpperCase() == "CREATELABEL")
						{
							if (nextCommand.length == 6)
							{
								this.animatedObjects.addLabelObject(parseInt(nextCommand[1]), nextCommand[2], this.parseBool(nextCommand[5]));						
							}
							else
							{
								this.animatedObjects.addLabelObject(parseInt(nextCommand[1]), nextCommand[2], true);
							}
							if (nextCommand.length >= 5)
							{
								
								this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseFloat(nextCommand[3]), parseFloat(nextCommand[4]));
							}
							undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));
						}
						else if (nextCommand[0].toUpperCase() == "SETEDGECOLOR")
						{
							var from = parseInt(nextCommand[1]);
							var to = parseInt(nextCommand[2]);
							var newColor = this.parseColor(nextCommand[3]);
							var oldColor = this.animatedObjects.setEdgeColor(from, to, newColor);				
							undoBlock.push(new UndoSetEdgeColor(from, to, oldColor));
						}
						else if (nextCommand[0].toUpperCase() == "SETEDGEALPHA")
						{
							var from = parseInt(nextCommand[1]);
							var to = parseInt(nextCommand[2]);
							var newAlpha = parseFloat(nextCommand[3]);
							var oldAplpha = this.animatedObjects.setEdgeAlpha(from, to, newAlpha);				
							undoBlock.push(new UndoSetEdgeAlpha(from, to, oldAplpha));
						}
						
						
						else if (nextCommand[0].toUpperCase() == "SETEDGEHIGHLIGHT")
						{
							var newHighlight = this.parseBool(nextCommand[3]);
							var from = parseInt(nextCommand[1]);
							var to = parseInt(nextCommand[2]);
							var oldHighlight = this.animatedObjects.setEdgeHighlight(from, to, newHighlight);
							undoBlock.push(new UndoHighlightEdge(from, to, oldHighlight));
						}
						else if (nextCommand[0].toUpperCase() == "SETHEIGHT")
						{
							id = parseInt(nextCommand[1]);
							var oldHeight = this.animatedObjects.getHeight(id);
							this.animatedObjects.setHeight(id, parseInt(nextCommand[2]));
							undoBlock.push(new UndoSetHeight(id, oldHeight));
						}
						else if (nextCommand[0].toUpperCase() == "SETLAYER")
						{
							this.animatedObjects.setLayer(parseInt(nextCommand[1]), parseInt(nextCommand[2]));
							//TODO: Add undo information here
						}
						
						
						else if (nextCommand[0].toUpperCase() == "CREATELINKEDLIST")
						{
							if (nextCommand.length == 11)
							{
								this.animatedObjects.addLinkedListObject(parseInt(nextCommand[1]), nextCommand[2], 
									parseInt(nextCommand[3]), parseInt(nextCommand[4]), parseFloat(nextCommand[7]), 
									this.parseBool(nextCommand[8]), this.parseBool(nextCommand[9]),parseInt(nextCommand[10]), "#FFFFFF", "#000000");
							}
							else
							{
								this.animatedObjects.addLinkedListObject(parseInt(nextCommand[1]), nextCommand[2], parseInt(nextCommand[3]), parseInt(nextCommand[4]), 0.25, true, false, 1, "#FFFFFF", "#000000");
							}
							if (nextCommand.length > 6)
							{
								this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseInt(nextCommand[5]), parseInt(nextCommand[6]));
								undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));
							}
							
						}
						else if (nextCommand[0].toUpperCase() == "SETNULL")
						{
							var oldNull = this.animatedObjects.getNull(parseInt(nextCommand[1]));
							this.animatedObjects.setNull(parseInt(nextCommand[1]), this.parseBool(nextCommand[2]));
							undoBlock.push(new UndoSetNull(parseInt(nextCommand[1]), oldNull));					
						}
						else if (nextCommand[0].toUpperCase() == "SETTEXTCOLOR")
						{
							if (nextCommand.length > 3)
							{
								oldColor = this.animatedObjects.getTextColor(parseInt(nextCommand[1]), parseInt(nextCommand[3]));
								this.animatedObjects.setTextColor(parseInt(nextCommand[1]), this.parseColor(nextCommand[2]), parseInt(nextCommand[3]));
								undoBlock.push(new UndoSetTextColor(parseInt(nextCommand[1]), oldColor, parseInt(nextCommand[3]) ));					
							}
							else
							{
								oldColor = this.animatedObjects.getTextColor(parseInt(nextCommand[1]), 0);
								this.animatedObjects.setTextColor(parseInt(nextCommand[1]),this.parseColor(nextCommand[2]), 0);
								undoBlock.push(new UndoSetTextColor(parseInt(nextCommand[1]), oldColor, 0));					
							}
						}
						
						
						else if (nextCommand[0].toUpperCase() == "CREATEBTREENODE")
						{

							this.animatedObjects.addBTreeNode(parseInt(nextCommand[1]), parseFloat(nextCommand[2]), parseFloat(nextCommand[3]), 
										parseInt(nextCommand[4]),this.parseColor(nextCommand[7]), this.parseColor(nextCommand[8]));
							this.animatedObjects.setNodePosition(parseInt(nextCommand[1]), parseInt(nextCommand[5]), parseInt(nextCommand[6]));
							undoBlock.push(new UndoCreate(parseInt(nextCommand[1])));
						}

						else if (nextCommand[0].toUpperCase() == "SETWIDTH")
						{
							var id = parseInt(nextCommand[1]);
							this.animatedObjects.setWidth(id, parseInt(nextCommand[2]));
							var oldWidth = this.animatedObjects.getWidth(id);
							undoBlock.push(new UndoSetWidth(id, oldWidth));
						}
						else if (nextCommand[0].toUpperCase() == "SETNUMELEMENTS")
						{
							var oldElem = this.animatedObjects.getObject(parseInt(nextCommand[1]));
							undoBlock.push(new UndoSetNumElements(oldElem, parseInt(nextCommand[2])));
							this.animatedObjects.setNumElements(parseInt(nextCommand[1]), parseInt(nextCommand[2]));
						}
						else if (nextCommand[0].toUpperCase() == "SETPOSITION")
						{
							var id = parseInt(nextCommand[1])
							var oldX = this.animatedObjects.getNodeX(id);
							var oldY = this.animatedObjects.getNodeY(id);
							undoBlock.push(new UndoSetPosition(id, oldX, oldY));
							this.animatedObjects.setNodePosition(id, parseInt(nextCommand[2]), parseInt(nextCommand[3]));
						}
						else if (nextCommand[0].toUpperCase() == "ALIGNRIGHT")
						{
							var id = parseInt(nextCommand[1])
							var oldX = this.animatedObjects.getNodeX(id);
							var oldY = this.animatedObjects.getNodeY(id);
							undoBlock.push(new UndoSetPosition(id, oldX. oldY));
							this.animatedObjects.alignRight(id, parseInt(nextCommand[2]));
						}
						else if (nextCommand[0].toUpperCase() == "ALIGNLEFT")
						{
							var id = parseInt(nextCommand[1])
							var oldX = this.animatedObjects.getNodeX(id);
							var oldY = this.animatedObjects.getNodeY(id);
							undoBlock.push(new UndoSetPosition(id, oldX. oldY));
							this.animatedObjects.alignLeft(id, parseInt(nextCommand[2]));
						}
						else if (nextCommand[0].toUpperCase() == "ALIGNTOP")
						{
							var id = parseInt(nextCommand[1])
							var oldX = this.animatedObjects.getNodeX(id);
							var oldY = this.animatedObjects.getNodeY(id);
							undoBlock.push(new UndoSetPosition(id, oldX. oldY));
							this.animatedObjects.alignTop(id, parseInt(nextCommand[2]));
						}
						else if (nextCommand[0].toUpperCase() == "ALIGNBOTTOM")
						{
							var id = parseInt(nextCommand[1])
							var oldX = this.animatedObjects.getNodeX(id);
							var oldY = this.animatedObjects.getNodeY(id);
							undoBlock.push(new UndoSetPosition(id, oldX. oldY));
							this.animatedObjects.alignBottom(id, parseInt(nextCommand[2]));
						}





						else if (nextCommand[0].toUpperCase() == "SETHIGHLIGHTINDEX")
						{
							var id = parseInt(nextCommand[1]);
							var index = parseInt(nextCommand[2]);
											var oldIndex = this.animatedObjects.getHighlightIndex(id)
							undoBlock.push(new UndoSetHighlightIndex(id, oldIndex));
							this.animatedObjects.setHighlightIndex(id,index);
						}
						else
						{
				//			throw "Unknown command: " + nextCommand[0];					
						}
						
						this.currentAnimation = this.currentAnimation+1;
					}
					this.currFrame = 0;

					// Hack:  If there are not any animations, and we are currently paused,
					// then set the current frame to the end of the anumation, so that we will
					// advance immediagely upon the next step button.  If we are not paused, then
					// animate as normal.

					if (!anyAnimations && this.animationPaused || (!anyAnimations && this.currentAnimation == this.AnimationSteps.length) )
					{
						this.currFrame = this.animationBlockLength;
					}

					this.undoStack.push(undoBlock);
				}

				//  Start a new animation.  The input parameter commands is an array of strings,
				//  which represents the animation to start
				this.StartNewAnimation =  function(commands)
				{
					clearTimeout(timer);
					if (this.AnimationSteps != null)
					{
						this.previousAnimationSteps.push(this.AnimationSteps);
						this.undoAnimationStepIndicesStack.push(this.undoAnimationStepIndices);
					}
					if (commands == undefined || commands.length == 0)
					{
						this.AnimationSteps = ["Step"];
					}
					else
					{
						this.AnimationSteps = commands;
					}
					this.undoAnimationStepIndices = new Array();
					this.currentAnimation = 0;
					this.startNextBlock();
					this.currentlyAnimating = true;
					this.fireEvent("AnimationStarted","NoData");
					timer = setTimeout('timeout()', 30); 

				}
				
				
				// Step backwards one step.  A no-op if the animation is not currently paused
				this.stepBack = function()
				{
					if (this.awaitingStep && this.undoStack != null && this.undoStack.length != 0)
					{
						//  TODO:  Get events working correctly!
						this.fireEvent("AnimationStarted","NoData");
						clearTimeout(timer);

						this.awaitingStep = false;
						this.undoLastBlock();
						// Re-kick thie timer.  The timer may or may not be running at this point,
						// so to be safe we'll kill it and start it again.
						clearTimeout(timer);
						timer = setTimeout('timeout()', 30); 

						
					}
					else if (!this.currentlyAnimating && this.animationPaused && this.undoAnimationStepIndices != null)
					{
						this.fireEvent("AnimationStarted","NoData");
						this.currentlyAnimating = true;
						this.undoLastBlock();
						// Re-kick thie timer.  The timer may or may not be running at this point,
						// so to be safe we'll kill it and start it again.
						clearTimeout(timer);
						timer = setTimeout('timeout()', 30); 
						
					}
					
				}
				// Step forwards one step.  A no-op if the animation is not currently paused
				this.step = function()
				{
					if (this.awaitingStep)
					{
						this.startNextBlock();
						this.fireEvent("AnimationStarted","NoData");
						this.currentlyAnimating = true;
						// Re-kick thie timer.  The timer should be going now, but we've had some difficulty with
						// it timing itself out, so we'll be safe and kick it now.
						clearTimeout(timer);
						timer = setTimeout('timeout()', 30); 			
					}
				}
				
				
				/// WARNING:  Could be dangerous to call while an animation is running ...
				this.clearHistory = function()
				{
					this.undoStack = [];
					this.undoAnimationStepIndices = null;
					this.previousAnimationSteps = [];
					this.undoAnimationStepIndicesStack = [];
					this.AnimationSteps = null;
					this.fireEvent("AnimationUndoUnavailable","NoData");
					clearTimeout(timer);
					this.animatedObjects.update();
					this.animatedObjects.draw();
					
				}
				
				this.skipBack = function()
				{
					var keepUndoing = this.undoAnimationStepIndices != null && this. undoAnimationStepIndices.length != 0;
					if (keepUndoing)
					{
						var i;
						for (i = 0; this.currentBlock != null && i < this.currentBlock.length; i++)
						{
							var objectID = this.currentBlock[i].objectID;
							this.animatedObjects.setNodePosition(objectID,
															this.currentBlock[i].toX,
															this.currentBlock[i].toY);
						}
						if (this.doingUndo)
						{
							this.finishUndoBlock(this.undoStack.pop())
						}
						while (keepUndoing)
						{
							this.undoLastBlock();
							for (i = 0; i < this.currentBlock.length; i++)
							{
								objectID = this.currentBlock[i].objectID;
								this.animatedObjects.setNodePosition(objectID,
																this.currentBlock[i].toX,
																this.currentBlock[i].toY);
							}
							keepUndoing = this.finishUndoBlock(this.undoStack.pop());
							
						}
						clearTimeout(timer);
						this.animatedObjects.update();
						this.animatedObjects.draw();
						if (this.undoStack == null || this.undoStack.length == 0)
						{
							this.fireEvent("AnimationUndoUnavailable","NoData");
						}

					}			
				}
				
				this.resetAll = function()
				{
					this.clearHistory();
					this.animatedObjects.clearAllObjects();
					this.animatedObjects.draw();
					clearTimeout(timer);
				}
				
				this.skipForward = function()
				{
					if (this.currentlyAnimating)
					{
						this.animatedObjects.runFast = true;
						while (this.AnimationSteps != null && this.currentAnimation < this.AnimationSteps.length)
						{
							var i;
							for (i = 0; this.currentBlock != null && i < this.currentBlock.length; i++)
							{
								var objectID = this.currentBlock[i].objectID;
								this.animatedObjects.setNodePosition(objectID,
																this.currentBlock[i].toX,
																this.currentBlock[i].toY);
							}
							if (this.doingUndo)
							{
								this.finishUndoBlock(this.undoStack.pop())
							}
							this.startNextBlock();
							for (i= 0; i < this.currentBlock.length; i++)
							{
								var objectID = this.currentBlock[i].objectID;
								this.animatedObjects.setNodePosition(objectID,
																this.currentBlock[i].toX,
																this.currentBlock[i].toY);
							}		
							
						}
						this.animatedObjects.update();
						this.currentlyAnimating = false;
						this.awaitingStep = false;
						this.doingUndo = false;
						
						this.animatedObjects.runFast = false;
						this.fireEvent("AnimationEnded","NoData");
						clearTimeout(timer);
						this.animatedObjects.update();
						this.animatedObjects.draw();			
					}
				}
				
				
				this.finishUndoBlock = function(undoBlock)
				{
					for (var i = undoBlock.length - 1; i >= 0; i--)
					{
						undoBlock[i].undoInitialStep(this.animatedObjects);
						
					}
					this.doingUndo = false;
					
					// If we are at the final end of the animation ...
					if (this.undoAnimationStepIndices.length == 0)
					{
						this.awaitingStep = false;
						this.currentlyAnimating = false;
						this.undoAnimationStepIndices = this.undoAnimationStepIndicesStack.pop();
						this.AnimationSteps = this.previousAnimationSteps.pop();
						this.fireEvent("AnimationEnded","NoData");
						this.fireEvent("AnimationUndo","NoData");
						this.currentBlock = [];
						if (this.undoStack == null || this.undoStack.length == 0)
						{
							this.currentlyAnimating = false;
							this.awaitingStep = false;
							this.fireEvent("AnimationUndoUnavailable","NoData");
						}
						
						clearTimeout(timer);
						this.animatedObjects.update();
						this.animatedObjects.draw();
						
						
						return false;
					}
					return true;
				}
				
				
				this.undoLastBlock = function()
				{
					
					if (this.undoAnimationStepIndices.length == 0)
					{
						
						// Nothing on the undo stack.  Return
						return;
						
					}
					if (this.undoAnimationStepIndices.length > 0)
					{
						this.doingUndo = true;
						var anyAnimations = false;
						this.currentAnimation = this.undoAnimationStepIndices.pop();
						this.currentBlock = [];
						var undo = this.undoStack[this.undoStack.length - 1];
						var i;
						for (i = undo.length - 1; i >= 0; i--)
						{
							var animateNext  =  undo[i].addUndoAnimation(this.currentBlock);
							anyAnimations = anyAnimations || animateNext;
							
						}
						this.currFrame = 0;
						
						// Hack:  If there are not any animations, and we are currently paused,
						// then set the current frame to the end of the animation, so that we will
						// advance immediagely upon the next step button.  If we are not paused, then
						// animate as normal.
						if (!anyAnimations && this.animationPaused  )
						{
							this.currFrame = this.animationBlockLength;
						}
						this.currentlyAnimating = true;				
					}
					
				}
				this.setLayer = function(shown, layers)
				{
					this.animatedObjects.setLayer(shown, layers)
					// Drop in an extra draw call here, just in case we are not
					// in the middle of an update loop when this changes
					this.animatedObjects.draw();
				}
				
				
				this.setAllLayers = function(layers)
				{
					this.animatedObjects.setAllLayers(layers);
					// Drop in an extra draw call here, just in case we are not
					// in the middle of an update loop when this changes
					this.animatedObjects.draw();
				}
				
				
				this.update = function()
				{
					
					if (this.currentlyAnimating)
					{
						this.currFrame = this.currFrame + 1;
						var i;
						for (i = 0; i < this.currentBlock.length; i++)
						{
							if (this.currFrame == this.animationBlockLength || (this.currFrame == 1 && this.animationBlockLength == 0))
							{
								this.animatedObjects.setNodePosition(this.currentBlock[i].objectID,
																	this.currentBlock[i].toX,
																	this.currentBlock[i].toY);
							}
							else if (this.currFrame < this.animationBlockLength)
							{
								var objectID = this.currentBlock[i].objectID;
								var percent = 1 / (this.animationBlockLength - this.currFrame);
								var oldX = this.animatedObjects.getNodeX(objectID);
								var oldY = this.animatedObjects.getNodeY(objectID);
								var targetX = this.currentBlock[i].toX;
								var targety  = this.currentBlock[i].toY;						
								var newX = this.lerp(this.animatedObjects.getNodeX(objectID), this.currentBlock[i].toX, percent);
								var newY = this.lerp(this.animatedObjects.getNodeY(objectID), this.currentBlock[i].toY, percent);
								this.animatedObjects.setNodePosition(objectID, newX, newY);
							}
						}
						if (this.currFrame >= this.animationBlockLength)
						{
							if (this.doingUndo)
							{
								if (this.finishUndoBlock(this.undoStack.pop()))
								{
									this.awaitingStep = true;
									this.fireEvent("AnimationWaiting","NoData");
								}

							}
							else
							{
								if (this.animationPaused && (this.currentAnimation < this.AnimationSteps.length))
								{
									this.awaitingStep = true;
									this.fireEvent("AnimationWaiting","NoData");
									this.currentBlock = [];
								}
								else
								{
									this.startNextBlock();
								}
							}
						}
						this.animatedObjects.update();		
					
					}

					
				}
				
			}

			AnimationManager.prototype = new EventListener();
			AnimationManager.prototype.constructor = AnimationManager;

							
			function SingleAnimation(id, fromX, fromY, toX, toY)
			{
				this.objectID = id;
				this.fromX = fromX;
				this.fromY = fromY;
				this.toX = toX;
				this.toY = toY;	
			}

            // Algorithm
            
			function addLabelToAlgorithmBar(labelName)
			{
				var element = document.createTextNode(labelName);
				
				var tableEntry = document.createElement("td");	
				tableEntry.appendChild(element);
				
				
				var controlBar = document.getElementById("AlgorithmSpecificControls");
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
				return element;
			}

			// TODO:  Make this stackable like radio butons
			//        (keep backwards compatible, thought)
			function addCheckboxToAlgorithmBar(boxLabel)
			{	
				var element = document.createElement("input");

				element.setAttribute("type", "checkbox");
				element.setAttribute("value", boxLabel);
				
				var label = document.createTextNode(boxLabel);
				
				var tableEntry = document.createElement("td");	
				tableEntry.appendChild(element);
				tableEntry.appendChild(label);
				
				var controlBar = document.getElementById("AlgorithmSpecificControls");
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
				return element;
			}

			function addRadioButtonGroupToAlgorithmBar(buttonNames, groupName)
			{
				var buttonList = [];
				var newTable = document.createElement("table");
					
				for (var i = 0; i < buttonNames.length; i++)
				{
					var midLevel = document.createElement("tr");
					var bottomLevel = document.createElement("td");
					
					var button = document.createElement("input");
					button.setAttribute("type", "radio");
					button.setAttribute("name", groupName);
					button.setAttribute("value", buttonNames[i]);
					bottomLevel.appendChild(button);
					midLevel.appendChild(bottomLevel);
					var txtNode = document.createTextNode(" " + buttonNames[i]); 
					bottomLevel.appendChild(txtNode);
					newTable.appendChild(midLevel);	
					buttonList.push(button);
				}
				
				var topLevelTableEntry = document.createElement("td");
				topLevelTableEntry.appendChild(newTable);
				
				var controlBar = document.getElementById("AlgorithmSpecificControls");
				controlBar.appendChild(topLevelTableEntry);
				
				return buttonList
			}


			function addControlToAlgorithmBar(type, name) {
				
				var element = document.createElement("input");
				
				element.setAttribute("type", type);
				element.setAttribute("value", name);
			//    element.setAttribute("name", name);
				
				
				var tableEntry = document.createElement("td");
				
				tableEntry.appendChild(element);
				
				
				var controlBar = document.getElementById("AlgorithmSpecificControls");
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
				return element;
				
			}

			function addNumberControlToAlgorithmBar(name, min, max, val) {
				
				var element = document.createElement("input");
				
				element.setAttribute("type", "number");
				element.setAttribute("id", name);
				element.setAttribute("min", min);
				element.setAttribute("max", max);
				element.setAttribute("value", val);
				
				
				var tableEntry = document.createElement("td");
				
				tableEntry.appendChild(element);
				
				
				var controlBar = document.getElementById("AlgorithmSpecificControls");
				
				//Append the element in page (in span).
				controlBar.appendChild(tableEntry);
				return element;
				
			}


			function Algorithm(am)
			{
				
			}



			Algorithm.prototype.setCodeAlpha = function(code, newAlpha)
			{
			var i,j;
			for (i = 0; i < code.length; i++)
				for (j = 0; j < code[i].length; j++) {
					this.cmd("SetAlpha", code[i][j], newAlpha);
				}
			}


			Algorithm.prototype.addCodeToCanvasBase  = function(code, start_x, start_y, line_height, standard_color, layer)
			{
					layer = typeof layer !== 'undefined' ? layer : 0;
				var codeID = Array(code.length);
				var i, j;
				for (i = 0; i < code.length; i++)
				{
					codeID[i] = new Array(code[i].length);
					for (j = 0; j < code[i].length; j++)
					{
						codeID[i][j] = this.nextIndex++;
						this.cmd("CreateLabel", codeID[i][j], code[i][j], start_x, start_y + i * line_height, 0);
						this.cmd("SetForegroundColor", codeID[i][j], standard_color);
						this.cmd("SetLayer", codeID[i][j], layer);
						if (j > 0)
						{
							this.cmd("AlignRight", codeID[i][j], codeID[i][j-1]);
						}
					}
					
					
				}
				return codeID;
			}


			Algorithm.prototype.init = function(am, w, h)
			{
				this.animationManager = am;
				am.addListener("AnimationStarted", this, this.disableUI);
				am.addListener("AnimationEnded", this, this.enableUI);
				am.addListener("AnimationUndo", this, this.undo);
				this.canvasWidth = w;
				this.canvasHeight = h;
				
				this.actionHistory = [];
				this.recordAnimation = true;
				this.commands = []
			}


			// Overload in subclass
			Algorithm.prototype.sizeChanged = function(newWidth, newHeight)
			{
				
			}


					
			Algorithm.prototype.implementAction = function(funct, val)
			{
				var nxt = [funct, val];			
				this.actionHistory.push(nxt);
				var retVal = funct(val);
				this.animationManager.StartNewAnimation(retVal);			
			}
					
					
			Algorithm.prototype.isAllDigits = function(str)
			{
				for (var i = str.length - 1; i >= 0; i--)
				{
					if (str.charAt(i) < "0" || str.charAt(i) > "9")
					{
						return false;

					}
				}
				return true;
			}
					
					
			Algorithm.prototype.normalizeNumber = function(input, maxLen)
			{
				if (!this.isAllDigits(input) || input == "")
				{
					return input;
				}
				else
				{
					return ("OOO0000" +input).substr(-maxLen, maxLen);
				}
			}
					
			Algorithm.prototype.disableUI = function(event)
			{
				// to be overridden in base class
			}

			Algorithm.prototype.enableUI = function(event)
			{
				// to be overridden in base class
			}



			function controlKey(keyASCII)
			{
					return keyASCII == 8 || keyASCII == 9 || keyASCII == 37 || keyASCII == 38 ||
				keyASCII == 39 || keyASCII == 40 || keyASCII == 46;
			}



			Algorithm.prototype.returnSubmitFloat = function(field, funct, maxsize)
			{
				if (maxsize != undefined)
				{
					field.size = maxsize;
				}
				return function(event)
				{
					var keyASCII = 0;
					if(window.event) // IE
					{
						keyASCII = event.keyCode
					}
					else if (event.which) // Netscape/Firefox/Opera
					{
						keyASCII = event.which
					} 
					// Submit on return
					if (keyASCII == 13)
					{
						funct();
					}
					// Control keys (arrows, del, etc) are always OK
					else if (controlKey(keyASCII))
					{
						return;
					}
					// - (minus sign) only OK at beginning of number
					//  (For now we will allow anywhere -- hard to see where the beginning of the
					//   number is ...)
					//else if (keyASCII == 109 && field.value.length  == 0)
					else if (keyASCII == 109)
					{
						return;
					}
					// Digis are OK if we have enough space
					else if ((maxsize != undefined || field.value.length < maxsize) &&
							(keyASCII >= 48 && keyASCII <= 57))
					{
						return;
					}
					// . (Decimal point) is OK if we haven't had one yet, and there is space
					else if ((maxsize != undefined || field.value.length < maxsize) &&
							(keyASCII == 190) && field.value.indexOf(".") == -1)
							
					{
						return;
					}
					// Nothing else is OK
					else 		
					{
						return false;
					}
					
				}
			}


			Algorithm.prototype.returnSubmit = function(field, funct, maxsize, intOnly)
			{
				if (maxsize != undefined)
				{
					field.size = maxsize;
				}
				return function(event)
				{
					var keyASCII = 0;
					if(window.event) // IE
					{
						keyASCII = event.keyCode
					}
					else if (event.which) // Netscape/Firefox/Opera
					{
						keyASCII = event.which
					} 

					if (keyASCII == 13 && funct !== null)
					{
						funct();
					}
							else if (keyASCII == 190 || keyASCII == 59 || keyASCII == 173 || keyASCII == 189)
					{ 
						return false;	
						
					}
					else if ((maxsize != undefined && field.value.length >= maxsize) ||
							intOnly && (keyASCII < 48 || keyASCII > 57))
					{
						if (!controlKey(keyASCII))
							return false;
					}
					
				}
				
			}

			Algorithm.prototype.addReturnSubmit = function(field, action)
			{
				field.onkeydown = this.returnSubmit(field, action, 4, false);	
			}

			Algorithm.prototype.reset = function()
			{
				// to be overriden in base class
				// (Throw exception here?)
			}
					
			Algorithm.prototype.undo = function(event)
			{
				// Remvoe the last action (the one that we are going to undo)
				this.actionHistory.pop();
				// Clear out our data structure.  Be sure to implement reset in
				//   every AlgorithmAnimation subclass!
				this.reset();
				//  Redo all actions from the beginning, throwing out the animation
				//  commands (the animation manager will update the animation on its own).
				//  Note that if you do something non-deterministic, you might cause problems!
				//  Be sure if you do anything non-deterministic (that is, calls to a random
				//  number generator) you clear out the undo stack here and in the animation
				//  manager.
				//
				//  If this seems horribly inefficient -- it is! However, it seems to work well
				//  in practice, and you get undo for free for all algorithms, which is a non-trivial
				//  gain.
				var len = this.actionHistory.length;
				this.recordAnimation = false;
				for (var i = 0; i < len; i++)
				{
					this.actionHistory[i][0](this.actionHistory[i][1]);
				}
				this.recordAnimation = true;
			}


			Algorithm.prototype.clearHistory = function()
			{
				this.actionHistory = [];
			}
					
					// Helper method to add text input with nice border.
					//  AS3 probably has a built-in way to do this.   Replace when found.
					

					// Helper method to create a command string from a bunch of arguments
			Algorithm.prototype.cmd = function()
			{
				if (this.recordAnimation)
				{
					var command = arguments[0];
					for(i = 1; i < arguments.length; i++)
					{
						command = command + "<;>" + String(arguments[i]);
					}
					this.commands.push(command);
				}
				
			}

            // B Tree
			var FIRST_PRINT_POS_X = 50;
			var PRINT_VERTICAL_GAP = 20;
			var PRINT_MAX = 990;
			var PRINT_HORIZONTAL_GAP = 50;

			var MIN_MAX_DEGREE = 3;
			var MAX_MAX_DEGREE = 8;

			var HEIGHT_DELTA  = 50;
			var NODE_SPACING = 3; 
			var STARTING_Y = 30;
			var WIDTH_PER_ELEM = 40;
			var NODE_HEIGHT = 20;

			var MESSAGE_X = 5;
			var MESSAGE_Y = 10;

			var LINK_COLOR = "#007700";
			var HIGHLIGHT_CIRCLE_COLOR = "#007700";
			var FOREGROUND_COLOR = "#007700";
			var BACKGROUND_COLOR = "#EEFFEE";
			var PRINT_COLOR = FOREGROUND_COLOR;



			function BTree(am, w, h)
			{
				this.init(am, w, h);

			}

			BTree.prototype = new Algorithm();
			BTree.prototype.varructor = BTree;
			BTree.superclass = Algorithm.prototype;
			BTree.prototype.init = function(am, w, h)
			{
				BTree.superclass.init.call(this, am, w, h);
				this.nextIndex = 0;

				this.starting_x = w / 2;

				this.preemptiveSplit = false;
				
				this.addControls();
				this.max_keys = 2;
				this.min_keys = 1;
				this.split_index = 1;
				
				this.max_degree = 3;

				this.messageID = this.nextIndex++;
				this.cmd("CreateLabel", this.messageID, "", MESSAGE_X, MESSAGE_Y, 0);
				this.moveLabel1ID = this.nextIndex++;
				this.moveLabel2ID = this.nextIndex++;
				
				animationManager.StartNewAnimation(this.commands);
				animationManager.skipForward();
				animationManager.clearHistory();
				this.commands = new Array();
				
				this.first_print_pos_y = h - 3 * PRINT_VERTICAL_GAP;

				
				this.xPosOfNextLabel = 100;
				this.yPosOfNextLabel = 200;
			}

			BTree.prototype.addControls =  function()
			{
				this.controls = [];
				
				this.insertField = addControlToAlgorithmBar("Text", "");
				this.insertField.onkeydown = this.returnSubmit(this.insertField,  this.insertCallback.bind(this), 4);
				this.controls.push(this.insertField);
				
				this.insertButton = addControlToAlgorithmBar("Button", "Insertar");
				this.insertButton.onclick = this.insertCallback.bind(this);
				this.controls.push(this.insertButton);
				
				this.deleteField = addControlToAlgorithmBar("Text", "");
				this.deleteField.onkeydown = this.returnSubmit(this.deleteField,  this.deleteCallback.bind(this), 4);
				this.controls.push(this.deleteField);
				
				this.deleteButton = addControlToAlgorithmBar("Button", "Eliminar");
				this.deleteButton.onclick = this.deleteCallback.bind(this);
				this.controls.push(this.deleteButton);
				
				this.findField = addControlToAlgorithmBar("Text", "");
				this.findField.onkeydown = this.returnSubmit(this.findField,  this.findCallback.bind(this), 4);
				this.controls.push(this.findField);
				
				this.findButton = addControlToAlgorithmBar("Button", "Buscar");
				this.findButton.onclick = this.findCallback.bind(this);
				this.controls.push(this.findButton);
				/*
				this.printButton = addControlToAlgorithmBar("Button", "Print");
				this.printButton.onclick = this.printCallback.bind(this);
				this.controls.push(this.printButton);
				*/
				
				this.clearButton = addControlToAlgorithmBar("Button", "Borrar todo");
				this.clearButton.onclick = this.clearCallback.bind(this);
				this.controls.push(this.clearButton);

				this.controls.push(addLabelToAlgorithmBar(" | Grado del arbol:"));
				this.degreeButton = addNumberControlToAlgorithmBar("Degree", 3, 8, 3);
				this.degreeButton.onchange = this.changeDegreeCallback.bind(this);
				this.controls.push(this.degreeButton);

				this.add10ElemsButton = addControlToAlgorithmBar("Button", "Agregar 10 elementos");
				this.add10ElemsButton.onclick = this.add10ElementCallback.bind(this);
				this.controls.push(this.add10ElemsButton);

				this.add100ElemsButton = addControlToAlgorithmBar("Button", "Agregar 20 elementos");
				this.add100ElemsButton.onclick = this.add100ElementCallback.bind(this);
				this.controls.push(this.add100ElemsButton);				
				/*
				var i;
				radioButtonNames = [];
				for (i = MIN_MAX_DEGREE; i <= MAX_MAX_DEGREE; i++)
				{
					radioButtonNames.push("Max. Degree = " + String(i));
				}
				
				this.maxDegreeRadioButtons = addRadioButtonGroupToAlgorithmBar(radioButtonNames, "MaxDegree");
				
				this.maxDegreeRadioButtons[0].checked = true;
				for(i = 0; i < this.maxDegreeRadioButtons.length; i++)
				{
					this.maxDegreeRadioButtons[i].onclick = this.maxDegreeChangedHandler.bind(this,i+MIN_MAX_DEGREE);
				}
				
				/*
				this.premptiveSplitBox = addCheckboxToAlgorithmBar("Preemtive Split / Merge (Even max degree only)");
				this.premptiveSplitBox.onclick = this.premtiveSplitCallback.bind(this);
				*/
				// Other buttons ...
				
			}	
			BTree.prototype.reset = function()
			{
				this.nextIndex = 3;
				this.max_degree = 3;
				this.max_keys = 2;
				this.min_keys = 1;
				this.split_index = 1;
				// NOTE: The order of these last two this.commands matters!
				this.treeRoot = null;
				this.ignoreInputs = true;
				// maxDegreeButtonArray[this.max_degree].selected = true;
				this.ignoreInputs = false;
			}

					
			BTree.prototype.enableUI = function(event)
			{
				var i;
				for (i = 0; i < this.controls.length; i++)
				{
					this.controls[i].disabled = false;
				}
				
				// TODO  Only enable even maxdegree if preemptive merge is on
				/*
				if (this.preemptiveSplit)
				{
					var initialEven = MIN_MAX_DEGREE % 2;
					var i;
					for (i = initialEven; i <= MAX_MAX_DEGREE - MIN_MAX_DEGREE; i+= 2)
					{
						this.maxDegreeRadioButtons[i].disabled = false;
					}
				}
				else
				{
					for (i = 0; i < this.maxDegreeRadioButtons.length; i++)
					{	
						this.maxDegreeRadioButtons[i].disabled = false;
					}
				}
				
				
				
				
				/*
				if (this.max_degree % 2 == 0)
				{
					this.premptiveSplitBox.disabled = false;
				}
				*/
				
			}
			BTree.prototype.disableUI = function(event)
			{
				for (var i = 0; i < this.controls.length; i++)
				{
					this.controls[i].disabled = true;
				}
				/*
				for (i = 0; i < this.maxDegreeRadioButtons.length; i++)
				{	
					this.maxDegreeRadioButtons[i].disabled = true;
				}
				*/
				//this.premptiveSplitBox.disabled = true;
				
				
				
			}


			//TODO:  Fix me!
			BTree.prototype.maxDegreeChangedHandler = function(newMaxDegree, event) 
			{
				if (this.max_degree != newMaxDegree)
				{
					this.implementAction(this.changeDegree.bind(this), newMaxDegree);
					animationManager.skipForward();
					animationManager.clearHistory();
				}
			}
					


			BTree.prototype.insertCallback = function(event)
			{
				var insertedValue;
				insertedValue = this.insertField.value;//this.normalizeNumber(this.insertField.value, 4);
				if (insertedValue != "" && !this.findInTree(this.treeRoot, insertedValue)) 
				{
					this.insertField.value = "";
					this.implementAction(this.insertElement.bind(this),insertedValue);
				} else {
					alert("El valor no se puede insertar ");
				}
			}

			
			BTree.prototype.insertCallbackB = function(insertedValue)
			{
				if (insertedValue != "")
				{
					this.insertField.value = "";
					this.implementAction(this.insertElement.bind(this),insertedValue);
				}
			}
					
			BTree.prototype.deleteCallback = function(event)
			{
				var deletedValue = this.deleteField.value;
				if (deletedValue != "")
				{
					deletedValue = this.deleteField.value;//this.normalizeNumber(this.deleteField.value, 4);
					this.deleteField.value = "";
					this.implementAction(this.deleteElement.bind(this),deletedValue);		
				}
			}
					
			BTree.prototype.clearCallback = function(event)
			{
				this.implementAction(this.clearTree.bind(this), "");
			}
			
			BTree.prototype.add10ElementCallback = function(event)
			{
				//this.implementAction(this.clearTree.bind(this), "");
				ival = 1;
				setTimeout(add10Elems, 1000);
			}

			BTree.prototype.add100ElementCallback = function(event)
			{
				//this.implementAction(this.clearTree.bind(this), "");
				ival = 1;
				setTimeout(add100Elems, 1000);
			}

			BTree.prototype.changeDegreeCallback = function(event)
			{
				var degree = this.degreeButton.value;
				this.implementAction(this.changeDegree.bind(this), degree);
			}

			/*		
			BTree.prototype.premtiveSplitCallback = function(event)
			{
				if (this.preemptiveSplit != this.premptiveSplitBox.checked)
				{
					this.implementAction(this.changePreemtiveSplit.bind(this), this.premptiveSplitBox.checked);
				}
			}
					
			BTree.prototype.changePreemtiveSplit = function(newValue)
			{
				this.commands = new Array();
				this.cmd("Step");
				this.preemptiveSplit = newValue;
				if (this.premptiveSplitBox.checked != this.preemptiveSplit)
				{
					this.premptiveSplitBox.checked = this.preemptiveSplit;
				}
				return this.commands;			
			}
			*/	

			BTree.prototype.printCallback = function(event) 
			{
				this.implementAction(this.printTree.bind(this),"");						
			}

			BTree.prototype.printTree = function(unused)
			{
				this.commands = new Array();
				this.cmd("SetText", this.messageID, "Printing tree");
				var firstLabel = this.nextIndex;
				
				this.xPosOfNextLabel = FIRST_PRINT_POS_X;
				this.yPosOfNextLabel = this.first_print_pos_y;
				
				this.printTreeRec(this.treeRoot);
				this.cmd("Step");
				for (var i = firstLabel; i < this.nextIndex; i++)
				{
					this.cmd("Delete", i);
				}
				this.nextIndex = firstLabel;
				this.cmd("SetText", this.messageID, "");
				return this.commands;
			}
					
			BTree.prototype.printTreeRec =function (tree)
			{
				this.cmd("SetHighlight", tree.graphicID, 1);
				var nextLabelID;
				if (tree.isLeaf)
				{
					for (var i = 0; i < tree.numKeys;i++)
					{
						nextLabelID = this.nextIndex++;
						this.cmd("CreateLabel", nextLabelID, tree.keys[i], this.getLabelX(tree, i), tree.y);
						this.cmd("SetForegroundColor", nextLabelID, PRINT_COLOR);
						this.cmd("Move", nextLabelID, this.xPosOfNextLabel, this.yPosOfNextLabel);
						this.cmd("Step");			
						this.xPosOfNextLabel +=  PRINT_HORIZONTAL_GAP;
						if (this.xPosOfNextLabel > PRINT_MAX)
						{
							this.xPosOfNextLabel = FIRST_PRINT_POS_X;
							this.yPosOfNextLabel += PRINT_VERTICAL_GAP;
						}
					}
					this.cmd("SetHighlight", tree.graphicID, 0);
				}
				else
				{
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[0].graphicID, 1);
					this.cmd("Step");
					this.cmd("SetHighlight", tree.graphicID, 0);
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[0].graphicID, 0);
					this.printTreeRec(tree.children[0]);
					for (i = 0; i < tree.numKeys; i++)
					{
						this.cmd("SetHighlight", tree.graphicID, 1);
						nextLabelID = this.nextIndex++;
						this.cmd("CreateLabel", nextLabelID, tree.keys[i], this.getLabelX(tree, i), tree.y);
						this.cmd("SetForegroundColor", nextLabelID, PRINT_COLOR);
						this.cmd("Move", nextLabelID, this.xPosOfNextLabel, this.yPosOfNextLabel);
						this.cmd("Step");			
						this.xPosOfNextLabel +=  PRINT_HORIZONTAL_GAP;
						if (this.xPosOfNextLabel > PRINT_MAX)
						{
							this.xPosOfNextLabel = FIRST_PRINT_POS_X;
							this.yPosOfNextLabel += PRINT_VERTICAL_GAP;
						}
						this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i+1].graphicID, 1);
						this.cmd("Step");
						this.cmd("SetHighlight", tree.graphicID, 0);
						this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i+1].graphicID, 0);
						this.printTreeRec(tree.children[i+1]);
					}
					this.cmd("SetHighlight", tree.graphicID, 1);
					this.cmd("Step");
					this.cmd("SetHighlight", tree.graphicID, 0);
					
				}
				
				
			}

			BTree.prototype.clearTree = function(ignored)
			{
				this.commands = new Array();
				this.deleteTree(this.treeRoot);
				this.treeRoot = null;
				this.nextIndex = 3;		
				return this.commands;
			}

			BTree.prototype.deleteTree = function(tree)
			{
				if (tree != null)
				{
					if (!tree.isLeaf)
					{
						for (var i = 0; i <= tree.numKeys; i++)
						{
							this.cmd("Disconnect", tree.graphicID, tree.children[i].graphicID);
							this.deleteTree(tree.children[i]);
							tree.children[i] == null;
						}
					}
					this.cmd("Delete", tree.graphicID);
				}
			}


			BTree.prototype.changeDegree = function(degree)
			{
				this.commands = new Array();
				this.deleteTree(this.treeRoot);
				this.treeRoot = null;
				this.nextIndex = 3;
				var newDegree = degree;
				//console.log(newDegree);
				this.ignoreInputs = true;
				//TODO:  Check me!
				//this.maxDegreeRadioButtons[newDegree - MIN_MAX_DEGREE].checked = true;
				
				this.ignoreInputs = false;
				this.max_degree = newDegree;
				this.max_keys = newDegree - 1;
				this.min_keys = Math.floor((newDegree + 1) / 2) - 1;
				this.split_index = Math.floor((newDegree - 1) / 2);
				if (this.commands.length == 0)
				{
					this.cmd("Step");
				}
				if (newDegree % 2 != 0 && this.preemptiveSplit)
				{
					this.preemptiveSplit = false;
					//this.premptiveSplitBox.checked = false;
				}
				return this.commands;
			}


			BTree.prototype.findCallback = function(event)
			{
				var findValue;
				findValue = this.findField.value;//this.normalizeNumber(this.findField.value, 4);
				this.findField.value = "";
				this.implementAction(this.findElement.bind(this),findValue);						
			}

			BTree.prototype.findElement = function(findValue)
			{
				this.commands = new Array();
				
				this.cmd("SetText", this.messageID, "Buscando " + findValue);
				this.findInTree(this.treeRoot, findValue);
				
				return this.commands;
			}

			BTree.prototype.findInTree = function(tree, val)
			{
				if (tree != null)
				{
					this.cmd("SetHighlight", tree.graphicID, 1);
					this.cmd("Step");
					var i;
					for (i = 0; i < tree.numKeys && tree.keys[i] < val; i++);
					if (i == tree.numKeys)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 0);
							return this.findInTree(tree.children[tree.numKeys], val);
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetText", this.messageID, "El elemento " + val + " no está en el árbol");
						}
					}
					else if (tree.keys[i] > val)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 0);					
							return this.findInTree(tree.children[i], val);
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetText", this.messageID, "El elemento " + val + " no está en el árbol");
						}
					}
					else
					{
						this.cmd("SetTextColor", tree.graphicID, "#FF0000", i);
						this.cmd("SetText", this.messageID, "El elemento " + val + " está en el árbol");
						this.cmd("Step");
						this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
						this.cmd("SetHighlight", tree.graphicID, 0);
						
						this.cmd("Step");
						return true;
					}
				}
				else
				{
					this.cmd("SetText", this.messageID, "El elemento " + val + " no está en el árbol");
				}
				return false;
			}


			BTree.prototype.insertElementB = function(insertedValue){
				this.commands = new Array();
				
				if (this.treeRoot == null)
				{
					this.treeRoot = new BTreeNode(this.nextIndex++, this.starting_x, STARTING_Y);
					this.treeRoot.keys[0] = insertedValue;
				}
				else
				{
					if (this.preemptiveSplit)
					{
						if (this.treeRoot.numKeys == this.max_keys)
						{
							this.splitB(this.treeRoot)
							this.resizeTreeB();
							
						}
						this.insertNotFullB(this.treeRoot, insertedValue);				
					}
					else
					{
						this.insertB(this.treeRoot, insertedValue);					
					}
					if (!this.treeRoot.isLeaf)
					{
						this.resizeTreeB();
					}
				}
			}

			BTree.prototype.insertElement = function(insertedValue)
			{
				this.commands = new Array();
				
				this.cmd("SetText", this.messageID, "Insertando " + insertedValue);
				this.cmd("Step");
				
				if (this.treeRoot == null)
				{
					this.treeRoot = new BTreeNode(this.nextIndex++, this.starting_x, STARTING_Y);
					this.cmd("CreateBTreeNode",
							this.treeRoot.graphicID, 
							WIDTH_PER_ELEM, NODE_HEIGHT, 
							1, 
							this.starting_x, 
							STARTING_Y, 
							BACKGROUND_COLOR,  
							FOREGROUND_COLOR);
					this.treeRoot.keys[0] = insertedValue;
					this.cmd("SetText", this.treeRoot.graphicID, insertedValue, 0);
				}
				else
				{
					if (this.preemptiveSplit)
					{
						if (this.treeRoot.numKeys == this.max_keys)
						{
							this.split(this.treeRoot)
							this.resizeTree();
							this.cmd("Step");
							
						}
						this.insertNotFull(this.treeRoot, insertedValue);				
					}
					else
					{
						this.insert(this.treeRoot, insertedValue);					
					}
					if (!this.treeRoot.isLeaf)
					{
						this.resizeTree();
					}
				}
				
				this.cmd("SetText", this.messageID, "");
				
				return this.commands;
				
			}

			BTree.prototype.insertNotFullB = function(tree, insertValue){
				if (tree.isLeaf)
				{
					tree.numKeys++;
					var insertIndex = tree.numKeys - 1;
					while (insertIndex > 0 && tree.keys[insertIndex - 1] > insertValue)
					{
						tree.keys[insertIndex] = tree.keys[insertIndex - 1];
						insertIndex--;
					}
					tree.keys[insertIndex] = insertValue;
					this.resizeTree();
				}
				else
				{
					var findIndex = 0;
					while (findIndex < tree.numKeys && tree.keys[findIndex] < insertValue)
					{
						findIndex++;					
					}			
					if (tree.children[findIndex].numKeys == this.max_keys)
					{
						var newTree = this.split(tree.children[findIndex]);
						this.resizeTree();
						this.insertNotFull(newTree, insertValue);
					}
					else
					{
						this.insertNotFull(tree.children[findIndex], insertValue);
					}
				}
			}

			BTree.prototype.insertNotFull = function(tree, insertValue)
			{
				this.cmd("SetHighlight", tree.graphicID, 1);
				this.cmd("Step");
				if (tree.isLeaf)
				{
					this.cmd("SetText", this.messageID, "Insertando " + insertValue + ".  Insertando en un nodo hoja");
					tree.numKeys++;
					this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
					var insertIndex = tree.numKeys - 1;
					while (insertIndex > 0 && tree.keys[insertIndex - 1] > insertValue)
					{
						tree.keys[insertIndex] = tree.keys[insertIndex - 1];
						this.cmd("SetText", tree.graphicID, tree.keys[insertIndex], insertIndex);
						insertIndex--;
					}
					tree.keys[insertIndex] = insertValue;
					this.cmd("SetText", tree.graphicID, tree.keys[insertIndex], insertIndex);
					this.cmd("SetHighlight", tree.graphicID, 0);
					this.resizeTree();
				}
				else
				{
					var findIndex = 0;
					while (findIndex < tree.numKeys && tree.keys[findIndex] < insertValue)
					{
						findIndex++;					
					}				
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[findIndex].graphicID, 1);
					this.cmd("Step");
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[findIndex].graphicID, 0);
					this.cmd("SetHighlight", tree.graphicID, 0);
					if (tree.children[findIndex].numKeys == this.max_keys)
					{
						var newTree = this.split(tree.children[findIndex]);
						this.resizeTree();
						this.cmd("Step");
						this.insertNotFull(newTree, insertValue);
					}
					else
					{
						this.insertNotFull(tree.children[findIndex], insertValue);
					}
				}
			}



			BTree.prototype.insert = function(tree, insertValue)
			{
				this.cmd("SetHighlight", tree.graphicID, 1);
				this.cmd("Step");
				if (tree.isLeaf)
				{
					this.cmd("SetText", this.messageID, "Insertando " + insertValue + ".  Insertando en un nodo hoja");
					tree.numKeys++;
					this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
					var insertIndex = tree.numKeys - 1;
					while (insertIndex > 0 && tree.keys[insertIndex - 1] > insertValue)
					{
						tree.keys[insertIndex] = tree.keys[insertIndex - 1];
						this.cmd("SetText", tree.graphicID, tree.keys[insertIndex], insertIndex);
						insertIndex--;
					}
					tree.keys[insertIndex] = insertValue;
					this.cmd("SetText", tree.graphicID, tree.keys[insertIndex], insertIndex);
					this.cmd("SetHighlight", tree.graphicID, 0);
					this.resizeTree();
					this.insertRepair(tree);
				}
				else
				{
					var findIndex = 0;
					while (findIndex < tree.numKeys && tree.keys[findIndex] < insertValue)
					{
						findIndex++;					
					}				
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[findIndex].graphicID, 1);
					this.cmd("Step");
					this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[findIndex].graphicID, 0);
					this.cmd("SetHighlight", tree.graphicID, 0);
					this.insert(tree.children[findIndex], insertValue);				
				}
			}

			BTree.prototype.insertB = function(tree, insertValue)
			{
				if (tree.isLeaf)
				{
					tree.numKeys++;
					var insertIndex = tree.numKeys - 1;
					while (insertIndex > 0 && tree.keys[insertIndex - 1] > insertValue)
					{
						tree.keys[insertIndex] = tree.keys[insertIndex - 1];
						insertIndex--;
					}
					tree.keys[insertIndex] = insertValue;
					this.resizeTree();
					this.insertRepair(tree);
				}
				else
				{
					var findIndex = 0;
					while (findIndex < tree.numKeys && tree.keys[findIndex] < insertValue)
					{
						findIndex++;					
					}				
					this.insert(tree.children[findIndex], insertValue);				
				}
			}

			BTree.prototype.insertRepair = function(tree) 
			{
				if (tree.numKeys <= this.max_keys)
				{
					return;
				}
				else if (tree.parent == null)
				{
					this.treeRoot = this.split(tree);
					return;
				}
				else
				{
					var newNode  = this.split(tree);
					this.insertRepair(newNode);
				}			
			}

			BTree.prototype.split = function(tree)
			{
				this.cmd("SetText", this.messageID, "Node now contains too many keys.  Splittig ...");
				this.cmd("SetHighlight", tree.graphicID, 1);
				this.cmd("Step");
				this.cmd("SetHighlight", tree.graphicID, 0);
				var rightNode = new BTreeNode(this.nextIndex++, tree.x + 100, tree.y);
				rightNode.numKeys = tree.numKeys - this.split_index - 1;
				var risingNode = tree.keys[this.split_index];
				
				
				if (tree.parent != null)
				{
					var currentParent = tree.parent;
					for (var parentIndex = 0; parentIndex < currentParent.numKeys + 1 && currentParent.children[parentIndex] != tree; parentIndex++);
					if (parentIndex == currentParent.numKeys + 1)
					{
						throw new Error("Couldn't find which child we were!");
					}
					this.cmd("SetNumElements", currentParent.graphicID, currentParent.numKeys + 1);
					for (i = currentParent.numKeys; i > parentIndex; i--)
					{
						currentParent.children[i+1] = currentParent.children[i];
						this.cmd("Disconnect", currentParent.graphicID, currentParent.children[i].graphicID);
						this.cmd("Connect", currentParent.graphicID,  currentParent.children[i].graphicID, FOREGROUND_COLOR, 
							0, // Curve
							0, // Directed
							"", // Label
							i+1);
						
						currentParent.keys[i] = currentParent.keys[i-1];
						this.cmd("SetText", currentParent.graphicID, currentParent.keys[i] ,i);
					}
					currentParent.numKeys++;
					currentParent.keys[parentIndex] = risingNode;
					this.cmd("SetText", currentParent.graphicID, "", parentIndex);
					this.moveLabel1ID = this.nextIndex++;
					this.cmd("CreateLabel", this.moveLabel1ID, risingNode, this.getLabelX(tree, this.split_index),  tree.y)
					this.cmd("SetForegroundColor", this.moveLabel1ID, FOREGROUND_COLOR);

					this.cmd("Move", this.moveLabel1ID,  this.getLabelX(currentParent, parentIndex),  currentParent.y)
					
					
					
					
					currentParent.children[parentIndex+1] = rightNode;
					rightNode.parent = currentParent;
					
				}
				
				
				this.cmd("CreateBTreeNode",
						rightNode.graphicID, 
						WIDTH_PER_ELEM, NODE_HEIGHT, 
						tree.numKeys - this.split_index - 1, 
						tree.x, 
						tree.y,  
						BACKGROUND_COLOR, 
						FOREGROUND_COLOR);
				
				var i;
				for (i = this.split_index + 1; i < tree.numKeys + 1; i++)
				{
					rightNode.children[i - this.split_index - 1] = tree.children[i];
					if (tree.children[i] != null)
					{
						rightNode.isLeaf = false;
						this.cmd("Disconnect", tree.graphicID, tree.children[i].graphicID);
						
						this.cmd("Connect", rightNode.graphicID, 
							rightNode.children[i - this.split_index - 1].graphicID,
							FOREGROUND_COLOR,
							0, // Curve
							0, // Directed
							"", // Label
							i - this.split_index - 1);
						if (tree.children[i] != null)
						{
							tree.children[i].parent = rightNode;
						}
						tree.children[i] = null;
						
					}
				}
				for (i = this.split_index+1; i < tree.numKeys; i++)
				{
					rightNode.keys[i - this.split_index - 1] = tree.keys[i];
					this.cmd("SetText", rightNode.graphicID, rightNode.keys[i - this.split_index - 1], i - this.split_index - 1);
				}
				var leftNode = tree;
				leftNode.numKeys = this.split_index;
				// TO MAKE UNDO WORK -- CAN REMOVE LATER VV
				for (i = this.split_index; i < tree.numKeys; i++)
				{
					this.cmd("SetText", tree.graphicID, "", i); 
				}
				// TO MAKE UNDO WORK -- CAN REMOVE LATER ^^
				this.cmd("SetNumElements", tree.graphicID, this.split_index);
				
				if (tree.parent != null)
				{
					this.cmd("Connect", currentParent.graphicID, rightNode.graphicID, FOREGROUND_COLOR, 
						0, // Curve
						0, // Directed
						"", // Label
						parentIndex + 1);
					this.resizeTree();
					this.cmd("Step")
					this.cmd("Delete", this.moveLabel1ID);				
					this.cmd("SetText", currentParent.graphicID, risingNode, parentIndex);
					return tree.parent;
				}
				else //			if (tree.parent == null)
				{
					this.treeRoot = new BTreeNode(this.nextIndex++, this.starting_x, STARTING_Y);
					this.cmd("CreateBTreeNode",
							this.treeRoot.graphicID, 
							WIDTH_PER_ELEM, 
							NODE_HEIGHT, 
							1, 
							this.starting_x, 
							STARTING_Y,
							BACKGROUND_COLOR,  
							FOREGROUND_COLOR);
					this.treeRoot.keys[0] = risingNode;
					this.cmd("SetText", this.treeRoot.graphicID, risingNode, 0);
					this.treeRoot.children[0] = leftNode;
					this.treeRoot.children[1] = rightNode;
					leftNode.parent = this.treeRoot;
					rightNode.parent = this.treeRoot;
					this.cmd("Connect", this.treeRoot.graphicID, leftNode.graphicID, FOREGROUND_COLOR, 
						0, // Curve
						0, // Directed
						"", // Label
						0);	// Connection Point
					this.cmd("Connect", this.treeRoot.graphicID, rightNode.graphicID, FOREGROUND_COLOR, 
						0, // Curve
						0, // Directed
						"", // Label
						1); // Connection Point
					this.treeRoot.isLeaf = false;
					return this.treeRoot;
				}
				
				
				
			}

			BTree.prototype.splitB = function(tree)
			{
				var rightNode = new BTreeNode(this.nextIndex++, tree.x + 100, tree.y);
				rightNode.numKeys = tree.numKeys - this.split_index - 1;
				var risingNode = tree.keys[this.split_index];
				
				
				if (tree.parent != null)
				{
					var currentParent = tree.parent;
					for (var parentIndex = 0; parentIndex < currentParent.numKeys + 1 && currentParent.children[parentIndex] != tree; parentIndex++);
					if (parentIndex == currentParent.numKeys + 1)
					{
						throw new Error("Couldn't find which child we were!");
					}
					for (i = currentParent.numKeys; i > parentIndex; i--)
					{
						currentParent.children[i+1] = currentParent.children[i];
						currentParent.keys[i] = currentParent.keys[i-1];
					}
					currentParent.numKeys++;
					currentParent.keys[parentIndex] = risingNode;
					this.moveLabel1ID = this.nextIndex++;
					currentParent.children[parentIndex+1] = rightNode;
					rightNode.parent = currentParent;
					
				}
				var i;
				for (i = this.split_index + 1; i < tree.numKeys + 1; i++)
				{
					rightNode.children[i - this.split_index - 1] = tree.children[i];
					if (tree.children[i] != null)
					{
						rightNode.isLeaf = false;
						if (tree.children[i] != null)
						{
							tree.children[i].parent = rightNode;
						}
						tree.children[i] = null;
						
					}
				}
				for (i = this.split_index+1; i < tree.numKeys; i++)
				{
					rightNode.keys[i - this.split_index - 1] = tree.keys[i];
				}
				var leftNode = tree;
				leftNode.numKeys = this.split_index;
				if (tree.parent != null)
				{
					this.resizeTree();
					return tree.parent;
				}
				else //			if (tree.parent == null)
				{
					this.treeRoot = new BTreeNode(this.nextIndex++, this.starting_x, STARTING_Y);
					this.treeRoot.keys[0] = risingNode;
					this.treeRoot.children[0] = leftNode;
					this.treeRoot.children[1] = rightNode;
					leftNode.parent = this.treeRoot;
					rightNode.parent = this.treeRoot;
					this.treeRoot.isLeaf = false;
					return this.treeRoot;
				}
					
			}

			BTree.prototype.deleteElement = function(deletedValue)
			{
				this.commands = new Array();
				this.cmd("SetText", 0, "Deleting "+deletedValue);
				this.cmd("Step");
				this.cmd("SetText", 0, "");
				this.highlightID = this.nextIndex++;
				this.cmd("SetText", 0, "");
				if (this.preemptiveSplit)
				{
					this.doDeleteNotEmpty(this.treeRoot, deletedValue);
				}
				else
				{
					this.doDelete(this.treeRoot, deletedValue);
					
				}
				if (this.treeRoot.numKeys == 0)
				{
					this.cmd("Step");
					this.cmd("Delete", this.treeRoot.graphicID);
					this.treeRoot = this.treeRoot.children[0];
					this.treeRoot.parent = null;
					this.resizeTree();
				}
				return this.commands;						
			}

			BTree.prototype.doDeleteNotEmpty = function(tree, val)
			{
				if (tree != null)
				{
					this.cmd("SetHighlight", tree.graphicID, 1);
					this.cmd("Step");
					var i;
					for (i = 0; i < tree.numKeys && tree.keys[i] < val; i++);
					if (i == tree.numKeys)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 0);
							
							if (tree.children[tree.numKeys].numKeys == this.min_keys)
							{
								var nextNode;
								if (tree.children[tree.numKeys - 1].numKeys > this.min_keys)
								{
									nextNode = this.stealFromLeft(tree.children[tree.numKeys], tree.numKeys)
									this.doDeleteNotEmpty(nextNode, val);
								}
								else
								{
									nextNode = this.mergeRight(tree.children[tree.numKeys - 1])
									this.doDeleteNotEmpty(nextNode, val);
								}
							}
							else
							{
								this.doDeleteNotEmpty(tree.children[tree.numKeys], val);							
							}
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
						}
					}
					else if (tree.keys[i] > val)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 0);					
							
							if (tree.children[i].numKeys > this.min_keys)
							{
								this.doDeleteNotEmpty(tree.children[i], val);
							}
							else
							{
								if (tree.children[i+1].numKeys > this.min_keys)
								{
									nextNode = this.stealFromRight(tree.children[i], i);
									this.doDeleteNotEmpty(nextNode, val);
								}
								else
								{
									nextNode = this.mergeRight(tree.children[i]);
									this.doDeleteNotEmpty(nextNode, val);
								}
								
							}
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
						}
					}
					else
					{
						this.cmd("SetTextColor", tree.graphicID, "FF0000", i);
						this.cmd("Step");
						if (tree.isLeaf)
						{
							this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
							for (var j = i; j < tree.numKeys - 1; j++)
							{
								tree.keys[j] = tree.keys[j+1];
								this.cmd("SetText", tree.graphicID, tree.keys[j], j);
							}
							tree.numKeys--;
							this.cmd("SetText", tree.graphicID, "", tree.numKeys);
							this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.resizeTree();
							this.cmd("SetText", this.messageID, "");
							
							
						}
						else
						{
							this.cmd("SetText", this.messageID, "Checking to see if tree to left of element to delete \nhas an extra key");
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 1);					
							
							
							this.cmd("Step");
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 0);					
							var maxNode = tree.children[i];
							
							if (tree.children[i].numKeys == this.min_keys)
							{
								
								this.cmd("SetText", this.messageID, 
										"Tree to left of element to delete does not have an extra key.  \nLooking to the right ...");
								this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i+1].graphicID, 1);
								this.cmd("Step");
								this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i + 1].graphicID, 0);	
								// Trees to left and right of node to delete don't have enough keys
								//   Do a merge, and then recursively delete the element
								if (tree.children[i+1].numKeys == this.min_keys)
								{
									this.cmd("SetText", this.messageID, 
											"Neither subtree has extra nodes.  Mergeing around the key to delete, \nand recursively deleting ...");
									this.cmd("Step");
									this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
									nextNode = this.mergeRight(tree.children[i]);
									this.doDeleteNotEmpty(nextNode, val);
									return;
								}
								else
								{
									this.cmd("SetText", this.messageID, 
											"Tree to right of element to delete does have an extra key. \nFinding the smallest key in that subtree ...");
									this.cmd("Step");
									
									var minNode = tree.children[i+1];
									while (!minNode.isLeaf)
									{
										
										this.cmd("SetHighlight", minNode.graphicID, 1);
										this.cmd("Step")
										this.cmd("SetHighlight", minNode.graphicID, 0);
										if (minNode.children[0].numKeys == this.min_keys)
										{
											if (minNode.children[1].numKeys == this.min_keys)
											{
												minNode = this.mergeRight(minNode.children[0]);
											}
											else
											{
												minNode = this.stealFromRight(minNode.children[0], 0);
											}
										}
										else
										{
											minNode = minNode.children[0];
										}
									}
									
									this.cmd("SetHighlight", minNode.graphicID, 1);
									tree.keys[i] = minNode.keys[0];
									this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
									this.cmd("SetText", tree.graphicID, "", i);
									this.cmd("SetText", minNode.graphicID, "", 0);
									
									this.cmd("CreateLabel", this.moveLabel1ID, minNode.keys[0], this.getLabelX(minNode, 0),  minNode.y)
									this.cmd("Move", this.moveLabel1ID, this.getLabelX(tree, i), tree.y);
									this.cmd("Step");
									this.cmd("Delete", this.moveLabel1ID);
									this.cmd("SetText", tree.graphicID, tree.keys[i], i);
									for (i = 1; i < minNode.numKeys; i++)
									{
										minNode.keys[i-1] = minNode.keys[i]
										this.cmd("SetText", minNode.graphicID, minNode.keys[i-1], i - 1);
									}
									this.cmd("SetText", minNode.graphicID, "",minNode.numKeys - 1);
									
									minNode.numKeys--;
									this.cmd("SetHighlight", minNode.graphicID, 0);
									this.cmd("SetHighlight", tree.graphicID, 0);
									
									this.cmd("SetNumElements", minNode.graphicID, minNode.numKeys);							
									this.resizeTree();
									this.cmd("SetText", this.messageID, "");
									
								}
							}
							else
							{
								
								this.cmd("SetText", this.messageID, 
										"Tree to left of element to delete does have \nan extra key. Finding the largest key in that subtree ...");
								this.cmd("Step");
								while (!maxNode.isLeaf)
								{
									this.cmd("SetHighlight", maxNode.graphicID, 1);
									this.cmd("Step")
									this.cmd("SetHighlight", maxNode.graphicID, 0);
									if (maxNode.children[maxNode.numKeys].numKeys == this.min_keys)
									{
										if (maxNode.children[maxNode.numKeys - 1] > this.min_keys)
										{
											maxNode = this.stealFromLeft(maxNode.children[maxNode.numKeys], maxNode.numKeys);
										}
										else
										{
											
										}	maxNode = this.mergeRight(maxNode.children[maxNode.numKeys-1]);
									}
									else
									{
										maxNode = maxNode.children[maxNode.numKeys];
									}
								}
								this.cmd("SetHighlight", maxNode.graphicID, 1);
								tree.keys[i] = maxNode.keys[maxNode.numKeys - 1];
								this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
								this.cmd("SetText", tree.graphicID, "", i);
								this.cmd("SetText", maxNode.graphicID, "", maxNode.numKeys - 1);
								this.cmd("CreateLabel", this.moveLabel1ID, tree.keys[i], this.getLabelX(maxNode, maxNode.numKeys - 1),  maxNode.y)
								this.cmd("Move", this.moveLabel1ID, this.getLabelX(tree, i), tree.y);
								this.cmd("Step");
								this.cmd("Delete", this.moveLabel1ID);
								this.cmd("SetText", tree.graphicID, tree.keys[i], i);
								maxNode.numKeys--;
								this.cmd("SetHighlight", maxNode.graphicID, 0);
								this.cmd("SetHighlight", tree.graphicID, 0);
								
								this.cmd("SetNumElements", maxNode.graphicID, maxNode.numKeys);
								this.resizeTree();
								this.cmd("SetText", this.messageID, "");
								
							}
							
						}
					}
					
				}
			}		


			BTree.prototype.doDelete = function(tree, val)
			{
				if (tree != null)
				{
					this.cmd("SetHighlight", tree.graphicID, 1);
					this.cmd("Step");
					var i;
					for (i = 0; i < tree.numKeys && tree.keys[i] < val; i++);
					if (i == tree.numKeys)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[tree.numKeys].graphicID, 0);
							this.doDelete(tree.children[tree.numKeys], val);
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
						}
					}
					else if (tree.keys[i] > val)
					{
						if (!tree.isLeaf)
						{
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 1);
							this.cmd("Step");
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.cmd("SetEdgeHighlight", tree.graphicID, tree.children[i].graphicID, 0);					
							this.doDelete(tree.children[i], val);
						}
						else
						{
							this.cmd("SetHighlight", tree.graphicID, 0);
						}
					}
					else
					{
						this.cmd("SetTextColor", tree.graphicID, "#FF0000", i);
						this.cmd("Step");
						if (tree.isLeaf)
						{
							this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
							for (var j = i; j < tree.numKeys - 1; j++)
							{
								tree.keys[j] = tree.keys[j+1];
								this.cmd("SetText", tree.graphicID, tree.keys[j], j);
							}
							tree.numKeys--;
							this.cmd("SetText", tree.graphicID, "", tree.numKeys);
							this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
							this.cmd("SetHighlight", tree.graphicID, 0);
							this.repairAfterDelete(tree);
						}
						else
						{
							var maxNode = tree.children[i];
							while (!maxNode.isLeaf)
							{
								this.cmd("SetHighlight", maxNode.graphicID, 1);
								this.cmd("Step")
								this.cmd("SetHighlight", maxNode.graphicID, 0);
								maxNode = maxNode.children[maxNode.numKeys];
							}
							this.cmd("SetHighlight", maxNode.graphicID, 1);
							tree.keys[i] = maxNode.keys[maxNode.numKeys - 1];
							this.cmd("SetTextColor", tree.graphicID, FOREGROUND_COLOR, i);
							this.cmd("SetText", tree.graphicID, "", i);
							this.cmd("SetText", maxNode.graphicID, "", maxNode.numKeys - 1);
							this.cmd("CreateLabel", this.moveLabel1ID, tree.keys[i], this.getLabelX(maxNode, maxNode.numKeys - 1),  maxNode.y)
							this.cmd("Move", this.moveLabel1ID, this.getLabelX(tree, i), tree.y);
							this.cmd("Step");
							this.cmd("Delete", this.moveLabel1ID);
							this.cmd("SetText", tree.graphicID, tree.keys[i], i);
							maxNode.numKeys--;
							this.cmd("SetHighlight", maxNode.graphicID, 0);
							this.cmd("SetHighlight", tree.graphicID, 0);
							
							this.cmd("SetNumElements", maxNode.graphicID, maxNode.numKeys);
							this.repairAfterDelete(maxNode);					
						}
					}
					
				}
			}



			BTree.prototype.mergeRight = function(tree) 
			{
				this.cmd("SetText", this.messageID, "Merging node");
				
				var parentNode = tree.parent;
				var parentIndex = 0;
				for (parentIndex = 0; parentNode.children[parentIndex] != tree; parentIndex++);
				var rightSib = parentNode.children[parentIndex+1];
				this.cmd("SetHighlight", tree.graphicID, 1);
				this.cmd("SetHighlight", parentNode.graphicID, 1);
				this.cmd("SetHighlight", rightSib.graphicID, 1);
				
				this.cmd("Step");
				this.cmd("SetNumElements", tree.graphicID, tree.numKeys + rightSib.numKeys + 1);
				tree.x = (tree.x + rightSib.x) / 2
				this.cmd("SetPosition", tree.graphicID, tree.x,  tree.y);
				
				tree.keys[tree.numKeys] = parentNode.keys[parentIndex];
				var fromParentIndex = tree.numKeys;
				//this.cmd("SetText", tree.graphicID, tree.keys[tree.numKeys], tree.numKeys);
				this.cmd("SetText", tree.graphicID, "", tree.numKeys);
				this.cmd("CreateLabel", this.moveLabel1ID, parentNode.keys[parentIndex],  this.getLabelX(parentNode, parentIndex),  parentNode.y);
				
				
				for (var i = 0; i < rightSib.numKeys; i++)
				{
					tree.keys[tree.numKeys + 1 + i] = rightSib.keys[i];
					this.cmd("SetText", tree.graphicID, tree.keys[tree.numKeys + 1 + i], tree.numKeys + 1 + i);
					this.cmd("SetText", rightSib.graphicID, "", i);
				}
				if (!tree.isLeaf)
				{
					for (i = 0; i <= rightSib.numKeys; i++)
					{
						this.cmd("Disconnect", rightSib.graphicID, rightSib.children[i].graphicID);
						tree.children[tree.numKeys + 1 + i] = rightSib.children[i];
						tree.children[tree.numKeys + 1 + i].parent = tree;
						this.cmd("Connect", tree.graphicID, 
							tree.children[tree.numKeys + 1 + i].graphicID,
							FOREGROUND_COLOR,
							0, // Curve
							0, // Directed
							"", // Label
							tree.numKeys + 1 + i);
					}
				}
				this.cmd("Disconnect", parentNode.graphicID, rightSib.graphicID);
				for (i = parentIndex+1; i < parentNode.numKeys; i++)
				{
					this.cmd("Disconnect", parentNode.graphicID, parentNode.children[i+1].graphicID);
					parentNode.children[i] = parentNode.children[i+1];
					this.cmd("Connect", parentNode.graphicID, 
						parentNode.children[i].graphicID,
						FOREGROUND_COLOR,
						0, // Curve
						0, // Directed
						"", // Label
						i);
					parentNode.keys[i-1] = parentNode.keys[i];
					this.cmd("SetText", parentNode.graphicID, parentNode.keys[i-1], i-1);					
				}
				this.cmd("SetText", parentNode.graphicID, "", parentNode.numKeys - 1);
				parentNode.numKeys--;
				this.cmd("SetNumElements", parentNode.graphicID, parentNode.numKeys);
				this.cmd("SetHighlight", tree.graphicID, 0);
				this.cmd("SetHighlight", parentNode.graphicID, 0);
			//	this.cmd("SetHighlight", rightSib.graphicID, 0);
				
			//	this.cmd("Step");
				this.cmd("Delete", rightSib.graphicID);
				tree.numKeys = tree.numKeys + rightSib.numKeys + 1;
				this.cmd("Move", this.moveLabel1ID, this.getLabelX(tree, fromParentIndex), tree.y);
				
				this.cmd("Step");
				// resizeTree();
				this.cmd("Delete", this.moveLabel1ID);
				this.cmd("SetText", tree.graphicID, tree.keys[fromParentIndex], fromParentIndex);
				
				this.cmd("SetText", this.messageID, "");
				return tree;
			}


			BTree.prototype.stealFromRight = function(tree, parentIndex) 
			{
				// Steal from right sibling
				var parentNode = tree.parent;
				
				this.cmd("SetNumElements", tree.graphicID, tree.numKeys+1);					
				
				this.cmd("SetText", this.messageID, "Stealing from right sibling");
				
				var rightSib = parentNode.children[parentIndex + 1];
				tree.numKeys++;
				
				this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
				
				
				
				
				
				
				
				this.cmd("SetText", tree.graphicID, "",  tree.numKeys - 1);
				this.cmd("SetText", parentNode.graphicID, "", parentIndex);
				this.cmd("SetText", rightSib.graphicID, "", 0);

				var tmpLabel1 = this.nextIndex++;
				var tmpLabel2 = this.nextIndex++;

				
				this.cmd("CreateLabel", tmpLabel1, rightSib.keys[0], this.getLabelX(rightSib, 0),  rightSib.y)
				this.cmd("CreateLabel", tmpLabel2, parentNode.keys[parentIndex], this.getLabelX(parentNode, parentIndex),  parentNode.y)
				this.cmd("SetForegroundColor", tmpLabel1, FOREGROUND_COLOR);
				this.cmd("SetForegroundColor", tmpLabel2, FOREGROUND_COLOR);
				
				this.cmd("Move", tmpLabel1, this.getLabelX(parentNode, parentIndex),  parentNode.y);
				this.cmd("Move", tmpLabel2, this.getLabelX(tree, tree.numKeys - 1), tree.y);
				
				this.cmd("Step")
				this.cmd("Delete", tmpLabel1);
				this.cmd("Delete", tmpLabel2);
				tree.keys[tree.numKeys - 1] = parentNode.keys[parentIndex];
				parentNode.keys[parentIndex] = rightSib.keys[0];
				
				
				
				this.cmd("SetText", tree.graphicID, tree.keys[tree.numKeys - 1], tree.numKeys - 1);
				this.cmd("SetText", parentNode.graphicID, parentNode.keys[parentIndex], parentIndex);
				if (!tree.isLeaf)
				{
					tree.children[tree.numKeys] = rightSib.children[0];
					tree.children[tree.numKeys].parent = tree;
					this.cmd("Disconnect", rightSib.graphicID, rightSib.children[0].graphicID);
					this.cmd("Connect", tree.graphicID, 
						tree.children[tree.numKeys].graphicID,
						FOREGROUND_COLOR,
						0, // Curve
						0, // Directed
						"", // Label
						tree.numKeys);	
					// TODO::CHECKME!
					
					for (var i = 1; i < rightSib.numKeys + 1; i++)
					{
						this.cmd("Disconnect", rightSib.graphicID, rightSib.children[i].graphicID);
						rightSib.children[i-1] = rightSib.children[i];
						this.cmd("Connect", rightSib.graphicID, 
							rightSib.children[i-1].graphicID,
							FOREGROUND_COLOR,
							0, // Curve
							0, // Directed
							"", // Label
							i-1);								
					}
					
				}
				for (i = 1; i < rightSib.numKeys; i++)
				{
					rightSib.keys[i-1] = rightSib.keys[i];
					this.cmd("SetText", rightSib.graphicID, rightSib.keys[i-1], i-1);
				}
				this.cmd("SetText", rightSib.graphicID, "", rightSib.numKeys-1);
				rightSib.numKeys--;
				this.cmd("SetNumElements", rightSib.graphicID, rightSib.numKeys);
				this.resizeTree();
				this.cmd("SetText", this.messageID, "");
				return tree;
				
			}


			BTree.prototype.stealFromLeft = function(tree, parentIndex) 
			{
				var parentNode = tree.parent;
				// Steal from left sibling
				tree.numKeys++;
				this.cmd("SetNumElements", tree.graphicID, tree.numKeys);
				this.cmd("SetText", this.messageID, "Node has too few keys.  Stealing from left sibling.");
				
				for (i = tree.numKeys - 1; i > 0; i--)
				{
					tree.keys[i] = tree.keys[i-1];
					this.cmd("SetText", tree.graphicID, tree.keys[i], i);
				}
				var leftSib = parentNode.children[parentIndex -1];
				
				this.cmd("SetText", tree.graphicID, "", 0);
				this.cmd("SetText", parentNode.graphicID, "", parentIndex - 1);
				this.cmd("SetText", leftSib.graphicID, "", leftSib.numKeys - 1);
				
				var tmpLabel1 = this.nextIndex++;
				var tmpLabel2 = this.nextIndex++;
				
				this.cmd("CreateLabel", tmpLabel1, leftSib.keys[leftSib.numKeys - 1], this.getLabelX(leftSib, leftSib.numKeys - 1),  leftSib.y)
				this.cmd("CreateLabel", tmpLabel2, parentNode.keys[parentIndex - 1], this.getLabelX(parentNode, parentIndex - 1),  parentNode.y)
				this.cmd("SetForegroundColor", tmpLabel1, FOREGROUND_COLOR);
				this.cmd("SetForegroundColor", tmpLabel2, FOREGROUND_COLOR);

				
				this.cmd("Move", tmpLabel1, this.getLabelX(parentNode, parentIndex - 1),  parentNode.y);
				this.cmd("Move", tmpLabel2, this.getLabelX(tree, 0), tree.y);
				
				this.cmd("Step")
				this.cmd("Delete", tmpLabel1);
				this.cmd("Delete", tmpLabel2);
				
				
				if (!tree.isLeaf)
				{
					for (var i = tree.numKeys; i > 0; i--)
					{
						this.cmd("Disconnect", tree.graphicID, tree.children[i-1].graphicID);
						tree.children[i] =tree.children[i-1];
						this.cmd("Connect", tree.graphicID, 
							tree.children[i].graphicID,
							FOREGROUND_COLOR,
							0, // Curve
							0, // Directed
							"", // Label
							i);
					}
					tree.children[0] = leftSib.children[leftSib.numKeys];
					this.cmd("Disconnect", leftSib.graphicID, leftSib.children[leftSib.numKeys].graphicID);
					this.cmd("Connect", tree.graphicID, 
						tree.children[0].graphicID,
						FOREGROUND_COLOR,
						0, // Curve
						0, // Directed
						"", // Label
						0);
					leftSib.children[leftSib.numKeys] = null;
					tree.children[0].parent = tree;
					
				}
				
				tree.keys[0] = parentNode.keys[parentIndex - 1];
				this.cmd("SetText", tree.graphicID, tree.keys[0], 0);						
				parentNode.keys[parentIndex-1] = leftSib.keys[leftSib.numKeys - 1];
				this.cmd("SetText", parentNode.graphicID, parentNode.keys[parentIndex - 1], parentIndex - 1);
				this.cmd("SetText", leftSib.graphicID,"", leftSib.numKeys - 1);
				
				leftSib.numKeys--;
				this.cmd("SetNumElements", leftSib.graphicID, leftSib.numKeys);
				this.resizeTree();
				this.cmd("SetText", this.messageID, "");
				return tree;
			}


			BTree.prototype.repairAfterDelete = function(tree)
			{
				if (tree.numKeys < this.min_keys)
				{
					if (tree.parent == null)
					{
						if (tree.numKeys == 0)
						{
							this.cmd("Step");
							this.cmd("Delete", tree.graphicID);
							this.treeRoot = tree.children[0];
							if (this.treeRoot != null)
								this.treeRoot.parent = null;
							this.resizeTree();
						}
					}
					else
					{
						var parentNode = tree.parent;
						for (var parentIndex = 0; parentNode.children[parentIndex] != tree; parentIndex++);
						if (parentIndex > 0 && parentNode.children[parentIndex - 1].numKeys > this.min_keys)
						{
							this.stealFromLeft(tree, parentIndex);
							
						}
						else if (parentIndex < parentNode.numKeys && parentNode.children[parentIndex + 1].numKeys > this.min_keys)
						{
							this.stealFromRight(tree,parentIndex);
							
						}
						else if (parentIndex == 0)
						{
							// Merge with right sibling
							var nextNode = this.mergeRight(tree);
							this.repairAfterDelete(nextNode.parent);			
						}
						else
						{
							// Merge with left sibling
							nextNode = this.mergeRight(parentNode.children[parentIndex-1]);
							this.repairAfterDelete(nextNode.parent);			
							
						}
						
						
					}
				}
			}

			BTree.prototype.getLabelX = function(tree, index) 
			{
				return tree.x - WIDTH_PER_ELEM * tree.numKeys / 2 + WIDTH_PER_ELEM / 2 + index * WIDTH_PER_ELEM;
			}

			BTree.prototype.resizeTree = function()
			{
				this.resizeWidths(this.treeRoot);
				this.setNewPositions(this.treeRoot, this.starting_x, STARTING_Y);
				this.animateNewPositions(this.treeRoot);
			}

			BTree.prototype.resizeTreeB = function()
			{
				this.resizeWidths(this.treeRoot);
				this.setNewPositions(this.treeRoot, this.starting_x, STARTING_Y);
			}
			BTree.prototype.setNewPositions = function(tree, xPosition, yPosition)
			{
				if (tree != null)
				{
					tree.y = yPosition;
					tree.x = xPosition;
					if (!tree.isLeaf)
					{
						var leftEdge = xPosition - tree.width / 2;
						var priorWidth = 0;
						for (var i = 0; i < tree.numKeys+1; i++)
						{
							this.setNewPositions(tree.children[i], leftEdge + priorWidth + tree.widths[i] / 2, yPosition+HEIGHT_DELTA);
							priorWidth += tree.widths[i];
						}
					}				
				}			
			}

			BTree.prototype.animateNewPositions = function(tree)
			{
				if (tree == null)
				{
					return;
				}
				var i;
				for (i = 0; i < tree.numKeys + 1; i++)
				{
					this.animateNewPositions(tree.children[i]);
				}
				this.cmd("Move", tree.graphicID, tree.x, tree.y);
			}

			BTree.prototype.resizeWidths = function(tree) 
			{
				if (tree == null)
				{
					return 0;
				}
				if (tree.isLeaf)
				{
					for (var i = 0; i < tree.numKeys + 1; i++)
					{
						tree.widths[i] = 0;
					}
					tree.width = tree.numKeys * WIDTH_PER_ELEM + NODE_SPACING;
					return tree.width;				
				}
				else
				{
					var treeWidth = 0;
					for (i = 0; i < tree.numKeys+1; i++)
					{
						tree.widths[i] = this.resizeWidths(tree.children[i]);
						treeWidth = treeWidth + tree.widths[i];
					}
					treeWidth = Math.max(treeWidth, tree.numKeys * WIDTH_PER_ELEM + NODE_SPACING);
					tree.width = treeWidth;
					return treeWidth;
				}
			}
				



			function BTreeNode(id, initialX, initialY)
			{
				this.widths = [];
				this.keys = [];
				this.children = [];
				this.x = initialX;
				this.y = initialY;
				this.graphicID = id;
				this.numKeys = 1;
				this.isLeaf = true;
				this.parent = null;
				
				this.leftWidth = 0;
				this.rightWidth = 0;
				
			}

			var tree;
			var ival = 1;
			function init()
			{
				var animManag = initCanvas();
				tree = new BTree(animManag, canvas.width, canvas.height);
				//setTimeout(myTimer, 1000);
			}
			function add10Elems() {
				if (ival++ < 10){
					tree.insertCallbackB(Math.floor(Math.random()*100));
					setTimeout(add10Elems, 5000);
				} 
			}
			function add100Elems() {
				if (ival++ < 20){
					tree.insertCallbackB(Math.floor(Math.random()*100));
					setTimeout(add100Elems, 7000);
				} 
			}
        </script>	
	 </head> 
	
	<body onload="init();" class="VisualizationMainPage">
		
		<div id = "container">
			
			<div id="header">  
				<h1>B-Trees</h1>
			</div>
			
			<div id = "mainContent"> 
			  
			  <div id = "algoControlSection">
			    <table id="AlgorithmSpecificControls"> </table> 
			  </div>
			  <canvas id="canvas" width="1000" height="500"></canvas>
			  
			  <div id = "generalAnimationControlSection">
				<table id="GeneralAnimationControls">  </table>		
			  </div>
			  
			</div> <!-- mainContent -->
			

		</div><!-- container -->
	</body>
</html>
